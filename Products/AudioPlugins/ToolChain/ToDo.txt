---------------------------------------------------------------------------------------------------
Bugs

We give the priorities from 1 to 5 with meanings:

[1]  Minor annoyance: cosmetic GUI issues, mildly inconvenient behavior
[2]  Major annoyance: things like unresponsive GUI or false GUI feedback
[3]  Minor feature not working (like zoom in a plot, highlighting of GUI elements)
[4]  Major feature not working (like setting an important DSP parameter)
[5]  Showstoppers: crashes, false state recalls, filter instability explosions, wrong signals, 
     Nans, infinities, ...

In addition to the priorities 1-5, we also use the following tags:

[Q]  Questionable behavior which might in fact be intended and therefore not strictly a bug
[F]  Fixed, not verified
[V]  Fixed and verified

For fixing a bug, the preferable workflow is to first write a unit test in the TestAppJURA project 
that triggers and checks the buggy behavior programmatically and only *then* fixing it. This way, 
we build up our suite of unit tests along the way.


- In jura_ToolChain.cpp at the bottom, there is a list of more bugs that affect the whole 
  ToolChain. -> Move this list to here. Try to reproduce the crashes in a unit test in TestAppJURA.

- Straightliner: 

  -[4] The preset doesn't include the Tuning. Maybe it should store the filename of the tuning file.
   The PolyphonicInstrumentEditor is subclass of TuningFileManager. That is wrong! 
   PolyphonicInstrumentAudioModule should have that responsibility and store the name of the tuning
   file as part of the preset and reload it on recall. Perhaps it's best to remove the Tuning 
   functionality from Straightliner and moe it into ToolChain. The infrastructure for that should 
   perhaps be to just augment all noteOn calls with an additional double noteFreq parameter. Then 
   we can do the key -> freq conversion in one central place in ToolChain and all modules will 
   receive the frequency in their noteOn calls, so we don't need much additional infrastructure to 
   support it. The tuning file in ToolChain could be integrated into a midi section together with
   tempo, keyboard, modwheel maybe performance parameters.

  -[4] In the release build of the VST plugin, the Osc "More" menu doesn't open. In release build 
   of standalone, there's no problem. -> Try a debug build of the plugin
   Oh - it does open - but it is in the background. It is not brought to the front.
   Check class WaveOscEditorContextMenu in jura_OscillatorStereo.h/cpp and also
   WaveOscEditor::rButtonClicked where the context menu is opened. There, we call
     contextMenu->toFront(true);
   but this doesn't seem to be enough? The doc says that toFront brings the component in front
   of its *siblings*. But maybe the outer editor counts not a ssibling but as parent? Maybe we need
   to call addToDesktop() as well? But we do that in WaveOscEditor::rButtonClicked
   https://docs.juce.com/master/classComponent.html#ad717da76012d971197fd8cf943f3e721
   It can also be checked with the WaveOscillatorModule. In this case, the menu is visible because
   the window that would obscure it is not big enough. But we may verify that the context menu is
   at the back by moving the main GUI over it
   -Maybe it's because when running it as plugin, the main GUI window runs in always-on-top mode 
    whereas in standalone, this is not the case? Ah - yes - and in Kushview Element, this always on
    top mode is optional. The little orange button in the top-left of the window toggles 
    always-on-top mode on/off. But in Tracktion waveform, this doesn't seem to work. However, an 
    older version of ToolChain doesn't seem to have this problem in Waveform - or ..well ..now they
    all do - but for a little moment, it seemed to work with one version. WTF! Maybe for windows 
    that are always on top, which one of them get precedence is determined by the exact sequence of
    the window creation?
   -Try, if this also affects my own popup menus



- [4] Quadrifex: load preset NonLinearReverb002. We hit a jassert in getParameterByName with a 
  Parameter name DryWetRatio. It may be the Harmonics and/or the Reverb algo

- [3] Scope: Switching to sync and then back does not seem to update the sync frequency to the old 
  value. When moving the ScanFreq slicer, we get back to the old setting.

- [4] Load ToolChain preset BrassyOsc, play a couple of notes, load preset ButterSnap. It will 
  click only on the note that was last played with the previous patch. Something about the voice 
  manager? Maybe it's a bug in Liberty? It seems to affect only liberty

- [3] MultiAnalyzer, waveform view: when zooming in, the horizontal scrollbar does not appear

- Quadrifex: 
  -[Q] PhaseStereoizer: when Dry/Wet is set to 100/0 (i.e. dry only), tweaking the other parameters
   (like PhaeOffset) still affects the sound. That seems to be wrong. If it's intentional, this
   should be documented. It's not what one would expect. When Mid/Side is set to 0/100 and 
   Dry/Wet to 100/0, the PhaseOffset parameter seems to have no effect. Check
   rosic::PhaseStereoizer::getSampleFrameStereo. Implement a unit test for it.

- TackMeter:
  -[2] It shortly freezes on midi note-off events
  -[2] It doesn't work at all in EqualizerAPO. The same is true for all analyzers. Seems like GUI 
   animations generally don't work there?

- Equalizer:
  -[1] When loading an EQ preset while ToolChain is plugged in in EqualizerAPO, the name of the 
   preset appears only for a short moment and is then replaced by "Equalizer". Check if this 
   happens in other hosts and/or standalone, too. Standalone, Kushview Element, Tracktion, 
   Bitwig: fine

- [4] LadderFilter: In EqulaizerAPO it looks like the filter has an overall gain of around -6 dB
  when no resonance is applied. That gets worse with resonance. -> Make a unit test that checks
  the DC gain. Resonance makes the bandpass asymmetric. I think, the makeup gain formula works only
  for LP24 mode

- [4] EngineersFilter: The frequency responses measured by EqualizerAPO look not exactly like they 
  should. There is some error going on in the stopband range - maybe numerical roundoff? 
  Increasing the FFT resolution doesn't help, so it's not a truncation issue. High order (20)
  Halpern bandpass with large bandwidth (around 6-7) is especially crazy. freq = 1000. It seems to 
  be real - it's audible. It affects Papoulis and Chebychev, too. For bandreject, it's even worse.
  Maybe it has to do with the precision of the polynomial root finder? But that wouldn't explain 
  why Chebychev filters are also affected. It affects only bandpass and bandreject - peak is not
  affectd. That's strange because peak/dip also uses the LP -> BP transform. Maybe try different
  implementation structures, e.g. SVF. It is strange that the effect is not reflected in the
  frequency response plot - it uses the actual filter coeffs, too.

- [1] WaveOscillator: Initially when not yet any file was loaded manually, the first click on the 
  "Next" button loads the first file in the current directory instead of the next one according to 
  the currently loaded one. 

- Liberty: Open TestNoise.xml. Go into the ColorFilter module (by clicking on the module in the 
  graph or on the name in the TreeView. Select the Out2 module. Many more cables are drawn in red 
  than should be. Also, it doesn't seem to be possible to disconnect cables - or i have forgotten 
  how. A selected cable should be removable by clicking on delete and/or by right-click. Ah - OK - 
  on right-click, one can choose "Delete Selection". Also: try to connect two cables to a single
  input pin - it will delete the first connection. Maybe it's not possible to connect multiple 
  outputs to one input and we need to include an explicit adder module to achieve that?

- [F] Here, someone says, that the sequencer in AcidDevil always runs at 140 bpm
  https://www.kvraudio.com/forum/viewtopic.php?p=7257577#p7257577
  https://www.kvraudio.com/forum/viewtopic.php?t=606099
  - This is not surprising because ToolChain itself currently has no mechanism in place to 
    retrieve the time-info from the host and pass it on to its sub-modules in the slots. 
  - Solution: Implement such a mechanism. Maybe by adding a virtual method setMidiTimeInfo to
    jura::AudioModule and in ToolChain::processBlock, retrieve the time-info from the host and
    loop over the slots to call that method to set it up. A refinement/optimization could be to do
    that only when at least one of the slots has a module that actually needs the time info (not 
    all do). That would require to keep track of that in the add/remove/replaceModule functions, 
    so it would be more code with more potential errors for later maintenance, so there's a 
    trade-off to be made: either always do that additinal loop thorugh all modules per block which 
    often may be unnecessary or tolerate some additional complication.
  - See: AudioProcessor::getPlayHead(), AudioPlayHead, AudioPlayHead::CurrentPositionInfo
  - There is some code in AudioPluginWithMidiIn::processBlock. We need to make sure that 
    ToolChainAudioModule::wantsTempoSyncInfo is true and implement 
    ToolChainAudioModule::setBeatsPerMinute
    ...soo - after all - there is actually already some infrastructure/mechanisam in place. It just
    needs to be used correctly.
  - OK - I added an implementation of ToolChain::setBeatsPerMinute ...that should perhaps solve it 
    when ToolChain is used as plugin. We still need some solution when it is used as Standalone. 
    Maybe like in Surge: have an optional keyboard at the bottom and next to it some midi settings
    like tempo

- [2] Scope: Sometimes the graphics vanishes in sync mode

- [1] Some glyphs in the big font are not so nice (m may be too wide - it's wider than M) and/or 
  inconsistent with the corresponding glyphs in smaller fonts (see Y,y)

---------------------------------------------------------------------------------------------------
Features

- Instruments should add their own output to what's already there to enable layering

- Maybe instruments should also be able to use their input signal as source like an oscillator that 
  can be shaped by the filters and effects. But how could we implement both? I think, maybe I 
  should give instruments two additional sliders:
  -A pass-through volume slider
  -A slider fro mixing the input with the other oscillators

- Maybe don't mix instruments/effects with modulators in the same slot-chain - have a separate 
  slot-chain for the modulators instead.

- Try to support LV2, see:
  https://jatinchowdhury18.medium.com/building-lv2-plugins-with-juce-and-cmake-d1f8937dbac3
  https://github.com/lv2-porting-project/JUCE
  https://github.com/lvtk/jlv2
  https://github.com/DISTRHO/JUCE

- Scope: let the envelope trigger the reset - good for viewing one-shots that should always start 
  left. Maybe auto-freeze when the scanning has reached the end and auto-unfreeze when a new 
  trigger is received.

- Global:
  - It would be nice, if all modules could also serve as (audio-rate) modulators. This is 
    complicated by the fact that modulators have only one output whereas the audio modules have two
    and by the fact that modulators are treated differently in the framwork - they are computed 
    first. Hmm...maybe it's not so important after all.
  - Master Volume slider
  - MIDI state display (active notes, bpm, maybe transport and ticks)
  - Global setup -> extend the color setup to have more stuff in it.
  - Way to move modules up and down in the chain. ideally per drag-and-drop but easier to implement
    would be up/down buttons that swap the current module with the previous/next (or do nothing in 
    case of first and last). ToolChain needs a swapModules(int index1, int index2) function
  - All modules for which layering with the input makes sense should have a PassThrough parameter.
    See SweepKicker for an example.
  - All modules which produce their own sound (generators and instruments) but for which it 
    nevertheless makes sense to pass the input into their DSP-section should have an "Input" or
    "InputGain" parameter. See FlatZapper for an example. Straightliner and AcidDevil could do 
    that, too. There, the input would be mixed to the internal osc output.
  - Basically, all modules where it makes sense should have gain parameters for in/out/thru just
    like midi devices for midi events. The out gains may be "Amplitude" and or "Volume"/"Level"
    parameters (the difference is that one is linear, the other in dB). The in gains may be named 
    "Input" (and should always be linear). The "thru" gains may be named "PassThrough" and should 
    also be linear.

 - Here: https://github.com/RobinSchmidt/RS-MET/issues/342  someone requests bringing back single
   purpose plugins, specifically FuncShaper. Just compiling with the line:
     jura::ToolChain *dummy = nullptr; return createPluginWithMidi(dummy, 10); 
   changed to 
     jura::FuncShaperAudioModule *dummy = nullptr; return createPluginWithoutMidi(dummy);
   in PluginProcessor.cpp does not seem to be enough to achieve that. The pluin identification
   mechanism will still say ToolChain. Also, when building the FuncShaper as standalone and then 
   again the ToolChain, the state recall of ToolChain will fail - expected and probably not a big 
   deal because noone will ever want to use single purpose plugins in standalone mode anyway. I 
   also have no idea what that would mean for automation, so...well...not sure, how feasible that 
   would be. Doing such a thing would require big infrastructural changes to the codebase. Maybe it
   would be better to fix the automatibility issue for ToolChain. To make it memory efficient, we 
   should perhaps factor out all the shared (DSP and GUI) code into a separate dll such that all 
   the plugins can be tiny. For the binary size, it doesn't matter, if we build ToolChain or 
   FuncShaper via changing the line. Another option could be to just dig out the legacy codebase 
   before creating ToolChain and uploading it all to GitHub to make the old plugins compilable
   again.

- GUI: The numbers for the slots in ToolChain are small for values of 6 upwards. Apparently, the 
  font doesn't have large enough glyphs.

---------------------------------------------------------------------------------------------------
Modules

- PhasyQ: Like EasyQ but with allpass filters. We could have different kinds of allpasses:
  1st order, 2nd order (biquad), allpass-delay, nested allpass-delay. How would a 2nd order 
  allpass delay work? Maybe it would be like the biquad but use x[n-M], x[n-M-1] instead of 
  x[n-1], x[n-2] and likewise for the delayed output y? Or maybe we need x[n-M], x[n-2*M]?
  Maybe each band/node could have itself a numStages parameter.

- StereoTool: Gain, Pan, Pos, M/S, Mono-Switch - show 2x2 gain matrix and make it editable, 
  too - i.e. link the parameters  Gain, Pan, Pos M/S  to  L2L, L2R, R2L, R2R

---------------------------------------------------------------------------------------------------
Improvements

- Quadrifex: the patches always contain for each slot a patch for every possible effect that 
  *could be* in the slot, regardless whether ot not it actually *is* in the slot. That's wasteful.
  Most of the time, the patch is in default state anyway, i.e. conatins no settings. Maybe make a 
  compromise: save the patch for the effect only if it contains (non-default) settings. Maybe write
  a containsPatchSettings() function that receives an xml patch. It should scan it (recursively) 
  for attributes and ignore the PatchFormat attribute. Save it only, if that function returns true.


---------------------------------------------------------------------------------------------------
Code Quality

- Use an enum class for listing the different effect algos in rosic::Quadrifex::effectAlgorithms.
  We should generally use enum classes for such options.


---------------------------------------------------------------------------------------------------
Cosmetic GUI issues (layout, appearance, etc.):

- Frequency displays have ticks at powers of two rather than (sub)multiples of 1 kHz

- In the Equalizer, there is some issue with the right border, I think. Also, the Range label is 
  cramped with the L/R or M/S buttons in stereo L/R and M/S mode

- Breakpoint modulator: the loop indicators are in an obtrusive yellow. This only affects the 
  "standalone" enve-gen editor - not the one used in Straightliner.

- Quadrifex: the routing menu is partially obscured by the routing graphics

- PitchShifter: should show the detected pitch on the GUI





