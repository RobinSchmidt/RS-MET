---------------------------------------------------------------------------------------------------
One-Pole

Consider a 1st order filter with the difference equation:

  y[n] = a*x[n] + b*y[n-1]
  
and assume that it has been applied to some input signal in a forward pass. Before applying 
the backward pass, we would conceptually have to keep running the filter for a very long time 
feeding zeros (in practice, until the response tail has decayed away sufficiently), then run 
the filter in the backward direction on the tail to "warm it up" and then, in warmed up state,
run it in backward direction over our actual data. The goal is to replace the tail ring-out 
and warm-up computations with directly setting initial state yNew of the filter for the 
backward pass from its known final state yOld after the forward pass and its coeffs. Let's 
call the last output state of our filter y (== yOld), then the tail of the forward pass is 
given by the expression:

  t[n] = y * b^n
  
where t[0] == y[N-1], where N is the toal number of input samples and counting starts at 
index 0. That means, the first tail sample is taken to be the final output sample of our 
filter (right?). To that tail, we now apply the filter running in reverse direction - the 
result we call s[n]. We get the difference equation:

  s[n] = a * t[n] + b * s[n+1] = a * y * b^n + b * s[n+1]
  
the s[n+1] is used for the recursion rather than s[n-1] because we are coming from the right
(future) direction. To get an expression for s[n], we can use wolfram alpha with the input:

  RSolve[s[n] - b*s[n+1] - a*y*b^n == 0, s[n], n]
  
which gives the result:

  s(n) = c (1/b)^(n - 1) - (a y (b^n - (1/b)^n))/(b^2 - 1) and c element Z
  
which is the general solution to our recursion equation and depends on a parameter c which 
we must select according to some boundary condition (it seems, we do not need to take the 
restriction that c should be an integer seriously - it can be a real number - why does wolfram
say it should be integer?). Our boundary condition is that s(inf) == 0. Defining 

  k := 1/b and p := a*y/(b^2 - 1)
  
we can rewrite s(n) more simply as:

  s(n) = c*k^(n-1) - p*(b^n-k^n)
       = c*k^(n-1) - p*b^n + p*k^n
       = c*k^(n-1) + p*k^n - p*b^n
       = c*k^(n-1) + p*k*k^(n-1) - p*b^n
       = (c + p*k) * k^(n-1) - p*b^n
       
We have |b| < 1, so |1/b| = |k| > 1, so as n -> inf, p*b^n -> 0, but (c+p*k) * k^(n-1) goes to
infinity unless c+p*k = 0. So, in order to assure s(inf) = 0, we need c+p*k = 0 which we solve for 
c:

  c = -p*k

To get our desired filter state, we evaluate s(n) at n=1:

  s(1) = c*k^(1-1) - p*(b^1-k^1) = c - p*(b-k)
  
So, that's it. In summary, the new filter recursion state yNew which serves as initial state 
before starting the backward pass is computed from the current recursion state yOld after the 
forward pass and the filter coeffs a,b as:

  k = 1/b; p = a*yOld/(b*b-1); c = -p*k; s(1) = yNew = c - p*(b-k);
  
This can be further simplifed into:

  yNew = a*yOld*b / (1-b*b)
  
using 1 div, 3 mul, 1 sub. Maybe make some experiments, which formula is numerically more 
accurate - maybe it's not the most efficient/simplified one? Maybe try to avoid dividing by
1-b^2 because that denominator becomes inaccurate as |b| gets close to 1 (which is typical).
We can transform it to (using y := yOld):

  yNew = a*y*b / (1-b*b) = a*y*b / (b*(1/b - b)) = ...

  

Why do we have to compute c manually from the boundary condition? Why does this code:
  RSolve[{s[n] - b*s[n+1] - a*y*b^n == 0, s[Infinity] == 0}, s[n], n] 
not work? A working example for solving a recursion with boundary condition is:
  RSolve[{a[n + 1] - 2 a[n] == 1, a[0] == 1}, a[n], n]

Note that when using the explicit formula to compute the tail s(n), it works well only when b 
is an (inverse) power of two because otherwise the numerical errors in the computations of c 
and p seem to mess up everything.

---------------------------------------------------------------------------------------------------
One-Pole/One-Zero

Now let's consider the slightly more complicated case of a one-pole/one-zero filter with the
difference equation:

  y[n] = a*x[n] + b*y[n-1] + d*x[n-1]
  
(we don't use c, because wolfram wants to use c for the free parameter in the solution - we want
to avoid confusion). Let's call the final input and output sample x1 and y1 respectively, so:

  x1 := x[N-1], y1 := y[N-1] 
  
where N is the length of the input signal. Let's call the tail signal resulting from the forward
pass again t[n] - we have:

  t[0] = y1
  t[1] = b*t[0] + d*x1 =      b*y1 + d*x1
  t[2] = b*t[1] + d*0  =   b*(b*y1 + d*x1)
  t[3] = b*t[2] + d*0  = b*b*(b*y1 + d*x1)
  t[n] = b^(n-1) * (b*y1 + d*x1)   for all n >= 1
  
defining

  q := b*y1 + d*x1
  
we can write this as:

  t[n] = b^(n-1) * q   for all n >= 1
  
The tail s[n] after both passes (forward/backward) satisfies the recurrence relation:

  s[n] = a*t[n] + b*s[n+1] + d*t[n+1]
       = a*q*b^(n-1) + b*s[n+1] + d*q*b^n
       
which we solve with wolfram alpha:

  RSolve[s[n] == a*q*b^(n-1) + b*s[n+1] + d*q*b^n , s[n], n]
  
which gives the result:

  s(n) = c (1/b)^(n - 1) - (q (b^n - (1/b)^n) (a + b d))/(b (b^2 - 1)) and c element Z
  
Defining:

  k := 1/b, p := q*(a+b*d) / (b*(b^2-1))
  
We can write this as:

  s(n) = c*k^(n-1) - p*(b^n-k^n)
       = (c+p*k) * k^(n-1) - p*b^n
       
which is the same formula as before in the one-pole/no-zero filter case. Our boundary condition is
again s(inf) = 0, so we again get our constant c as:

  c = -p*k    as before
  
In summary, to set our state new variables in the filter, we may use: 

  q = b*y1 + d*x1
  p = q*(a+b*d) / (b*(b^2-1))
  k = 1/b
  c = -p*k
  xNew = t[1] = q
  yNew = s[1] = c - p*(b-k)
  
But this can be further simplified, for example by sage via:

  var("x y a b c d q p k y1")
  #q = b*y + d*x  # better not define q in terms of other variables - we need it for x1
  p = q*(a+b*d) / (b*(b^2-1))
  k = 1/b
  c = -p*k
  y1 = c - p*(b-k)
  y1.simplify_full()
  
which results in:

  -(b*d + a)*q/(b^2 - 1)
  
eventually, given the x1,y1 values after the forward pass, we can compute the new, updated x1,y1
states needed to run the backward pass via:

  x1 = b*y1 + d*x1               // update x1
  y1 = (b*d + a)*x1 / (1 - b^2)  // updating y1 uses the updated x1
  
---------------------------------------------------------------------------------------------------
Arbitrary boundary condition

So far, we have applied the boundary condition that the tail (after both passes) should approach 
zero as n approaches infinity: s(inf) == 0. This was motivated by the idea that the input signal 
is assumed to go down to zero after the samples for which we have data, i.e. x[n] = 0 for n >= N. 
In some cases, we may want to assume that the input signal goes to some nonzero constant value 
instead. For example, in image filtering, it may make more sense to imagine the last actual pixel 
value to be repeated over and over, i.e. x[n] = r for n >= N where we choose r = x[N-1]. That 
implies that our tail should also approach that same nonzero value: s(inf) == r. That requires us 
to modify the tail equation for the forward tail t[n] as follows:

  t[0] = y1
  t[1] = a*r + b*t[0] + d*x1 = a*r + b*y1 + d*x1
  t[2] = a*r + b*t[1] + d*r  = (a+d)*r + b*t[1] = (a+d)*r + b*(a*r + b*y1 + d*x1)
  t[3] = a*r + b*t[2] + d*r  = (a+d)*r + b*t[2] = (a+d)*r + b*((a+d)*r + b*(a*r + b*y1 + d*x1))
  ...
  
defining:
  
  q := a*r + b*y1 + d*x1, u = (a+d)*r
  
we get:

  t[1] = q
  t[2] = u + b*t[1] = u + b*q                         = u                       + b  *q
  t[3] = u + b*t[2] = u + b*(u + b*q)                 = u + b*u                 + b^2*q
  t[4] = u + b*t[3] = u + b*(u + b*(u + b*q))         = u + b*u + b^2*u         + b^3*q
  t[5] = u + b*t[4] = u + b*(u + b*(u + b*(u + b*q))) = u + b*u + b^2*u + b^3*u + b^4*q

and in general, for n >= 2:

  t[n] = q*b^(n-1) + u * sum_i b^i  where i = 0,...,n-2
  
The geometric sum: sum_i b^i evaluates to (1-b^(n-1)) / (1-b), see:
  https://en.wikipedia.org/wiki/Geometric_series
  https://mathworld.wolfram.com/GeometricSeries.html
so we get:

  t[n] = q*b^(n-1) + u * (1-b^(n-1)) / (1-b)
       = q*b^(n-1) + (u*1 - u*b^(n-1)) / (1-b)
       = q*b^(n-1) + u/(1-b) - (u/(1-b)) * b^(n-1)     define: v := u/(1-b)
       = q*b^(n-1) + v - v * b^(n-1)
       = v + (q-v)*b^(n-1)                             for n >= 2

The tail s[n] after both passes (forward/backward) satisfies the recurrence relation:

  s[n] = a*t[n] + b*s[n+1] + d*t[n+1]
       = a*(v + (q-v)*b^(n-1)) + b*s[n+1] + d*(v + (q-v)*b^n)
  
...tbc...
  
  
  

difference equation: y[n] = a*x[n] + b*y[n-1] + d*x[n-1]



===================================================================================================





under construction:

---------------------------------------------------------------------------------------------------
Two-Zero

y[n] = u*x[n] + v*x[n-1] + w*x[n-2]

t[0] = y[N-1]
t[1] = v*x[N-1] + w*x[N-2] = v*x1 + w*x2
t[2] = w*x[N-1] = w*x1
t[3] = 0

s[n] = u*t[n] + v*t[n+1] + w*t[n+2]

Let x1, x2 be the final states, then:

s[1] = u*t[1] + v*t[2] + w*t[3] = u*(v*x1 + w*x2) + v*w*x1
s[2] = u*t[2] + v*t[3] + w*t[4] = u*w*x1

...not yet tested





---------------------------------------------------------------------------------------------------
Two-Pole

y[n] = x[n] + a*y[n-1] + b*y[n-2]

Let y1, y2 be the final states, then:

t0 = y1
t1 = a*y1 + b*y2
t2 = a*t1 + b*t0 = a*y1 + b*(a*y1 + b*y2)
t3 = a*t2 + b*t1 = a*(a*y1 + b*(a*y1 + b*y2)) + b*(a*y1 + b*y2)


RSolve[s[n] == a*s[n+1] + b*s[n+2] + t[n], s[n], n]

s(n) = 2^(-n) ((-sqrt(a^2 + 4 b)/b - a/b)^n sum_(k_1 =0)^(n - 1)-(2^(-k_1 - 1) (sqrt(a^2 + 4 b) - a) t(k_1) ((sqrt(a^2 + 4 b) - a)/b)^(k_1) (1/(sqrt(a^2 + 4 b) + a))^(-k_1) (-(sqrt(a^2 + 4 b) + a)/b)^(-k_1))/sqrt(a^2 + 4 b) + (sqrt(a^2 + 4 b)/b - a/b)^n sum_(k_2 =0)^(n - 1)-(2^(-k_2 - 1) t(k_2) (1/(sqrt(a^2 + 4 b) + a))^(-k_2 - 1))/sqrt(a^2 + 4 b)) + c_1 2^(-n) (-sqrt(a^2 + 4 b)/b - a/b)^n + c_2 2^(-n) (sqrt(a^2 + 4 b)/b - a/b)^n and (c_1, c_2) element Z^2

S := sqrt(a^2 + 4 b)
s(n) = 2^(-n) ((-S/b - a/b)^n sum_(k_1 =0)^(n - 1)-(2^(-k_1 - 1) (S - a) t(k_1) ((S - a)/b)^(k_1) (1/(S + a))^(-k_1) (-(S + a)/b)^(-k_1))/S + (S/b - a/b)^n sum_(k_2 =0)^(n - 1)-(2^(-k_2 - 1) t(k_2) (1/(S + a))^(-k_2 - 1))/S) + c_1 2^(-n) (-S/b - a/b)^n + c_2 2^(-n) (S/b - a/b)^n

maybe to fix the 2nd constant we need to apply as 2nd boundary condition ds(inf) = 0 where
ds[n] = s[n+1] - s[n] 


maybe for two-pole filters (and higher order) filters, we should express them as parallel 
connection of complex one-pole filters and use our solution for one-pole-filters above. For image
filters, we may approximate a Gaussian filter by using multiple first order lowpass filters in 
series. Highpass is obtained by identity-minus-lowpass and bandpass and bandreject are obtained by 
series and parallel connection of lowpass and highpass. And/or maybe use connections using allpass
filters - maybe there's a type in which a1 is not close to 1 to avoid numerical problems in the 
formula in prepareForBackwardPass

---------------------------------------------------------------------------------------------------
Two-Pole/One-Zero






---------------------------------------------------------------------------------------------------
Biquad

Now let's consider a biquad filter with the difference equation:

  y[n] = u*x[n] + v*x[n-1] + w*x[n-2] + a*y[n-1] + b*y[n-2]
  
Let's call the final states after completing the formar pass x1 = x[N-1], x2 = x[N-2], 
y1 = y[N-1], y2 = y[N-2] and our goal is once again to find a formula how to update them before 
running the backward pass. The tail of the forward pass is:
  
  t0 = y1                         // 0th tail sample is last actual output sample y[N-1]
  t1 = v*x1 + w*x2 + a*y1 + b*y2  // computed directly
  t2 = w*x1 + a*t1 + b*t0         // computed directly
  t3 = a*t2 + b*t1                // computed recursively
  t4 = a*t3 + b*t2 = a*(a*t2 + b*t1) + b*t2
  t5 = a*t4 + b*t3 = a*(a*(a*t2 + b*t1) + b*t2) + b*(a*t2 + b*t1)
  t6 = a*t5 + b*t4 = a*(a*(a*(a*t2+b*t1)+b*t2)+b*(a*t2+b*t1)) + b*(a*(a*t2+b*t1)+b*t2)
  
...for each tn we want a formula using only a,b,t1,t2...the terms blow up quickly. It's difficult 
to find an explicit expression for tn, so let's use Wolfram alpha for this. Define:

  g = t1, h = t2

and use RSolve with initial conditions::

  RSolve[{t[n] == a*t[n-1] + b*t[n-2], t[1] == g, t[2] == h}, t[n], n]
  
This gives an ugly result:

t(n) = -(2^(-n - 1) (a^2 g (a - sqrt(a^2 + 4 b))^n + 2 b g (a - sqrt(a^2 + 4 b))^n + a g sqrt(a^2 + 4 b) (a - sqrt(a^2 + 4 b))^n - a^2 g (sqrt(a^2 + 4 b) + a)^n - 2 b g (sqrt(a^2 + 4 b) + a)^n + a g sqrt(a^2 + 4 b) (sqrt(a^2 + 4 b) + a)^n - a h (a - sqrt(a^2 + 4 b))^n - h sqrt(a^2 + 4 b) (a - sqrt(a^2 + 4 b))^n + a h (sqrt(a^2 + 4 b) + a)^n - h sqrt(a^2 + 4 b) (sqrt(a^2 + 4 b) + a)^n))/(b sqrt(a^2 + 4 b))

but with some manual extraction of common subexpressions and simplfications, we can turn this into:

  S = sqrt(a*a + 4*b)
  T = a - S 
  U = a + S
  V = a^2*g + 2*b*g - a*h
  W = a*g*S - h*S
  A = W+V
  B = W-V
  t(n) = -(A*T^n + B*U^n) / (b*S*2^(n+1))
  
From now on, we only need the numbers A,B,S,T,U in addition to the variables, we already have. Note 
that we may have to use complex numbers, when a*a + 4*b < 0. Now, let's write down the recurrence 
relation for the tail with the biquad filter applied bidirectionally:

  s[n] = u*t[n] + v*t[n+1] + w*t[n+2] + a*s[n+1] + b*s[n+2]
  
and insert our expression for t[n]:

  s[n] = a*s[n+1] + b*s[n+2]
         - u * (A*T^n     + B*U^n)     / (b*S*2^(n+1))
         - v * (A*T^(n+1) + B*U^(n+1)) / (b*S*2^(n+2))
         - w * (A*T^(n+2) + B*U^(n+2)) / (b*S*2^(n+3))

and throw that at RSolve:
         
  RSolve[s[n] == a*s[n+1] + b*s[n+2] - u*(A*T^n+B*U^n)/(b*S*2^(n+1)) - v*(A*T^(n+1)+B*U^(n+1))/(b*S*2^(n+2)) - w*(A*T^(n+2)+B*U^(n+2))/(b*S*2^(n+3)), s[n], n]

...hmm...wolfram alpha says: "doesn't understand your query" -> try wolfram cloud and/or sage.
wolfram cloud can do it but the result is a monster...
But this:

  RSolve[s[n] == a*s[n+1] + b*s[n+2] - u*t[n] - v*t[n+1] - w*t[n+2], s[n], n]
  

  
where we do not yet have inserted our expression for t[n] gives a managable result:

s(n) = 2^(-n) ((-sqrt(a^2 + 4 b)/b - a/b)^n ( sum_(k_1 =-2)^(n - 1) (2^(-k_1 - 1) (sqrt(a^2 + 4 b) - a) ((sqrt(a^2 + 4 b) - a)/b)^(k_1) (1/(sqrt(a^2 + 4 b) + a))^(-k_1) (-(sqrt(a^2 + 4 b) + a)/b)^(-k_1) (u t(k_1) + v t(k_1 + 1) + w t(k_1 + 2)))/sqrt(a^2 + 4 b)) + (sqrt(a^2 + 4 b)/b - a/b)^n sum_(k_2 =-2)^(n - 1) (2^(-k_2 - 1) (1/(sqrt(a^2 + 4 b) + a))^(-k_2 - 1) (u t(k_2) + v t(k_2 + 1) + w t(k_2 + 2)))/sqrt(a^2 + 4 b)) + c_1 2^(-n) (-sqrt(a^2 + 4 b)/b - a/b)^n + c_2 2^(-n) (sqrt(a^2 + 4 b)/b - a/b)^n and (c_1, c_2) element Z^2

wait - that's wrong! we need plusses for the u,v,w terms:
  
  RSolve[s[n] == a*s[n+1] + b*s[n+2] + u*t[n] + v*t[n+1] + w*t[n+2], s[n], n]

giving:

s(n) = 2^(-n) ((-sqrt(a^2 + 4 b)/b - a/b)^n sum_(k_1 =-2)^(n - 1)-(2^(-k_1 - 1) (sqrt(a^2 + 4 b) - a) ((sqrt(a^2 + 4 b) - a)/b)^(k_1) (1/(sqrt(a^2 + 4 b) + a))^(-k_1) (-(sqrt(a^2 + 4 b) + a)/b)^(-k_1) (u t(k_1) + v t(k_1 + 1) + w t(k_1 + 2)))/sqrt(a^2 + 4 b) + (sqrt(a^2 + 4 b)/b - a/b)^n sum_(k_2 =-2)^(n - 1)-(2^(-k_2 - 1) (1/(sqrt(a^2 + 4 b) + a))^(-k_2 - 1) (u t(k_2) + v t(k_2 + 1) + w t(k_2 + 2)))/sqrt(a^2 + 4 b)) + c_1 2^(-n) (-sqrt(a^2 + 4 b)/b - a/b)^n + c_2 2^(-n) (sqrt(a^2 + 4 b)/b - a/b)^n and (c_1, c_2) element Z^2



which we again may manually simplify to:


For a biquad, we need to compute the states y[n-1], y[n-2], so we need to evaluate our 
resulting formula at n=1 and n=2. The state values x[n-1], x[n-2] will be set to t[1],t[2]


---------------------------------------------------------------------------------------------------

Now let's consider a biquad filter with the difference equation:

  y[n] = b0*x[n] + b1*x[n-1] + b2*x[n-2] - a1*y[n-1] - a2*y[n-2]

we have changed the notation for the coeffients here to be consistent with the majority of DSP 
literature. Let's call the final states after completing the formar pass x1 = x[N-1], x2 = x[N-2], 
y1 = y[N-1], y2 = y[N-2] and our goal is once again to find a formula how to update them before 
running the backward pass. The tail of the forward pass is:

  t[0] = y1   // 1st tail sample is defined as being the last actual output sample y[N-1]
  t[1] = b1*x1 + b2*x2 - a1*y1 - a2*y2 =: t1
  t[2] = b2*x2 - a1*t[1] - a2*t[0] = b2*x2 - a1*(b1*x1+b2*x2-a1*y1-a2*y2) - a2*(y1) =: t2
  t[3] = -a1*t[2] - a2*t[1] = -a1*t2 - a2*t1
  t[4] = -a1*t[3] - a2*t[2] = -a1*(-a1*t2 - a2*t1) - a2*t2
  t[5] = -a1*t[4] - a2*t[3] = -a1*(-a1*(-a1*t2 - a2*t1) - a2*t2) - a2*(-a1*t2 - a2*t1)


  

var("a1 a2 t1 t2 t5")
t5 = -a1*(-a1*(-a1*t2 - a2*t1) - a2*t2) - a2*(-a1*t2 - a2*t1)
t5.simplify_full()
  







