#include "WaveTable.h"

WaveTable::WaveTable()
{
 // init member variables:
 sampleRate = 44100.0; 
 waveform   = 0;       

 // init the double-type versions of the tableSize
 tableLengthDbl       = (double) tableLength;       // typecasted versions
 tableLengthDiv2Dbl   = (double) tableLengthDiv2;
 tableLengthMinus1Dbl = (double) tableLengthMinus1;
	tableLengthRec       = 1.0/tableLengthDbl;         // reciprocal
 rec16384             = 1.0/16384.0; //reciprocal of 16384

 // set up the fourier-transformer:
 fourierTransformer.setBlockSize(tableLength);

 // initialize the buffers:
 initPrototypeTable();
 initTableSet();
}

WaveTable::~WaveTable()
{

}

//----------------------------------------------------------------------------
// parameter settings:

void WaveTable::setWaveform(int newWaveform)
{
	if( (newWaveform >= 0) && (newWaveform != waveform) )
 {
  waveform = newWaveform;

  switch(newWaveform)
  {
   case   1:  fillWithSine();                    break;
   case   2:  fillWithTriangle();                break;
   case   3:  fillWithPulse();                   break;
   case   4:  fillWithSawUp();                   break;
   case   5:  fillWithSawDown();                 break;
   case   6:  fillWithPeakUp();                  break;
   case   7:  fillWithPeakDown();                break;
   case   8:  fillWithMoogSaw();                 break;
   case   9:  fillWithSqrMinusSin();             break;
   case  10:  fillWithBrownSineOcts();           break;
   case  11:  fillWithSawOcts();                 break;
   case  12:  fillWithNoiseCycle(0);             break;
   case  13:  fillWithNoiseCycle(1);             break;
   case  14:  fillWithNoiseCycle(2);             break;
   case  15:  fillWithTriangleModulation();      break;
   case  16:  fillWithSineSweepUp(1.0, 64.0);    break;
   case  17:  fillWithSineSweepDown(1.0, 64.0);  break;

   /*
   //from here: specialized LFO-waveforms which are generated by adding
   //octave-spaced standard waveforms to generate "fractal" modulations:
   case  14:  fillWithSineOcts(2);          break;
   case  15:  fillWithSineOctsAlt(2);       break;
   case  16:  fillWithTriangleOcts(2);      break;
   case  17:  fillWithTriangleOctsAlt(2);   break;
   case  18:  fillWithPulseOcts(2);         break;
   case  19:  fillWithPulseOctsAlt(2);      break;
   case  20:  fillWithSawUpOcts(2);         break;
   case  21:  fillWithSawUpOctsAlt(2);      break;
   case  22:  fillWithSawDownOcts(2);       break;
   case  23:  fillWithSawDownOctsAlt(2);    break;

   case  24:  fillWithSineOcts(3);          break;
   case  25:  fillWithSineOctsAlt(3);       break;
   case  26:  fillWithTriangleOcts(3);      break;
   case  27:  fillWithTriangleOctsAlt(3);   break;
   case  28:  fillWithPulseOcts(3);         break;
   case  29:  fillWithPulseOctsAlt(3);      break;
   case  30:  fillWithSawUpOcts(3);         break;
   case  31:  fillWithSawUpOctsAlt(3);      break;
   case  32:  fillWithSawDownOcts(3);       break;
   case  33:  fillWithSawDownOctsAlt(3);    break;

   case  34:  fillWithSineOcts(4);          break;
   case  35:  fillWithSineOctsAlt(4);       break;
   case  36:  fillWithTriangleOcts(4);      break;
   case  37:  fillWithTriangleOctsAlt(4);   break;
   case  38:  fillWithPulseOcts(4);         break;
   case  39:  fillWithPulseOctsAlt(4);      break;
   case  40:  fillWithSawUpOcts(4);         break;
   case  41:  fillWithSawUpOctsAlt(4);      break;
   case  42:  fillWithSawDownOcts(4);       break;
   case  43:  fillWithSawDownOctsAlt(4);    break;

   case  44:  fillWithSineOcts(5);          break;
   case  45:  fillWithSineOctsAlt(5);       break;
   case  46:  fillWithTriangleOcts(5);      break;
   case  47:  fillWithTriangleOctsAlt(5);   break;
   case  48:  fillWithPulseOcts(5);         break;
   case  49:  fillWithPulseOctsAlt(5);      break;
   case  50:  fillWithSawUpOcts(5);         break;
   case  51:  fillWithSawUpOctsAlt(5);      break;
   case  52:  fillWithSawDownOcts(5);       break;
   case  53:  fillWithSawDownOctsAlt(5);    break;

   case  54:  fillWithSineOcts(6);          break;
   case  55:  fillWithSineOctsAlt(6);       break;
   case  56:  fillWithTriangleOcts(6);      break;
   case  57:  fillWithTriangleOctsAlt(6);   break;
   case  58:  fillWithPulseOcts(6);         break;
   case  59:  fillWithPulseOctsAlt(6);      break;
   case  60:  fillWithSawUpOcts(6);         break;
   case  61:  fillWithSawUpOctsAlt(6);      break;
   case  62:  fillWithSawDownOcts(6);       break;
   case  63:  fillWithSawDownOctsAlt(6);    break;

   case  14:  fillWithH1_4_7();        break;
   case  15:  fillWithH2_5_8();        break;
   case  16:  fillWithH3_6_9();        break;
   case  11:  fillWithEvenOnly();      break;
   */

   default :  fillWithSine();          break;
  } // end of switch
 } // end of if...

}

void WaveTable::setWaveform(double* newWaveForm, int lengthInSamples)
{
 int i;
 if( lengthInSamples == tableLength )
 {
  // just copy the values into the internal buffer, when the length of the
  // passed table and the internal table match:
  for( i=0; i<tableLength; i++ )
   prototypeTable[i] = newWaveForm[i];
 }
 else
 {
  // implement periodic sinc-interpolation here...
 }
 generateMultiSample();
}

//----------------------------------------------------------------------------
// internal functions:

void WaveTable::initPrototypeTable()
{
 for(int i=0; i<(tableLength+4); i++)
  prototypeTable[i] = 0.0;
}

void WaveTable::initTableSet()
{
 int t, i; // indices fo table and position
 for(t=0; t<numTables; t++)
  for(i=0; i<tableLength+4; i++)
   tableSet[t][i] = 0.0;
}

void WaveTable::removeDC()
{
 // calculate DC-offset (= average value of the table):
 double dcOffset = 0.0;
 int i;
 for(i=0; i<tableLength; i++)
  dcOffset += prototypeTable[i];
 dcOffset = dcOffset / tableLengthDbl;

 // remove DC-Offset:
 for(i=0; i<tableLength; i++)
  prototypeTable[i] -= dcOffset;
}

void WaveTable::normalize()
{
 // find maximum:
 double max = 0.0;
 int    i;
 for(i=0; i<tableLength; i++)
  if( fabs(prototypeTable[i]) > max)
   max = fabs(prototypeTable[i]);

 // normalize to amplitude 1.0:
 double scale = 1.0/max;
 for(i=0; i<tableLength; i++)
  prototypeTable[i] *= scale;
}

void WaveTable::reverseTime()
{
 static intA i;
 static doubleA tmpTable[tableLength+4];

 for(i=0; i<tableLength; i++)
  tmpTable[i] = prototypeTable[tableLength-i-1];

 for(i=0; i<tableLength; i++)
  prototypeTable[i] = tmpTable[i];
}

void WaveTable::generateMultiSample()
{
 static double spectrum[tableLength];
 //static int    position, offset;
 static int t, i; // indices for the table and position

 //position = 0;             // begin of the 1st table (index 0)
 //offset   = tableLength+4; // offset between tow tables, the 4 is the number
                           // of additional samples used for interpolation

 // copy the prototypeTable into the 1st table of the
 // multisample (this actually makes the prototypeTable
 // redundant - room for optimization here):
 t = 0;
 for(i=0; i<tableLength; i++)
  tableSet[0][i] = prototypeTable[i];

 // additional sample(s) for the interpolator:
 tableSet[t][tableLength]   = tableSet[t][0];
 tableSet[t][tableLength+1] = tableSet[t][1];
 tableSet[t][tableLength+2] = tableSet[t][2];
 tableSet[t][tableLength+3] = tableSet[t][3];

 // get the spectrum from the prototype-table:
 fourierTransformer.getReAndImFromSig(prototypeTable, spectrum);

 // ensure that DC and Nyquist are zero:
 spectrum[0] = 0.0;
 spectrum[1] = 0.0;

 // now, render the bandlimited versions by successively shrinking the
 // spectrum by one octave and iFFT'ing this spectrum:
 int lowBin, highBin;
 for(t=1; t<numTables; t++)
 {
  lowBin  = (int) (tableLength / pow(2.0, t));   // the cutoff-bin
  highBin = (int) (tableLength / pow(2.0, t-1)); // the bin up to which the
                                                 // spectrum is currently
                                                 // still nonzero

  // zero out the bins above the cutoff-bin:
  for(i=lowBin; i<highBin; i++)
   spectrum[i] = 0.0;

  // transform the truncated spectrum back to the time-domain and store it in
  // the tableSet
  fourierTransformer.getSigFromReAndIm(spectrum, tableSet[t]);

  // additional sample(s) for the interpolator:
  tableSet[t][tableLength]   = tableSet[t][0];
  tableSet[t][tableLength+1] = tableSet[t][1];
  tableSet[t][tableLength+2] = tableSet[t][2];
  tableSet[t][tableLength+3] = tableSet[t][3];
 }

 /*
 // generate the spectrum for the second table by setting
 // frequencies in the second half of the spectrum to zero amplitude:
 for(i=tableLength/2; i<tableLength; i++)
  spectrum[i] = 0.0;

 // the next table should begin at postion
 // 0+tableSize+interpolationSamples:
 position = position + offset; //begin of the next table

 // fill the second table with the waveform corresponding to
 // the truncated spectrum:
 fourierTransformer.getSigFromReAndIm(spectrum, tables+position);

 // copy the first sample of the table into the additional position for
 // the interpolator:
 tables[position+tableLength]   = tables[position];
 tables[position+tableLength+1] = tables[position+1];
 tables[position+tableLength+2] = tables[position+2];
 tables[position+tableLength+3] = tables[position+3];

 // generate the spectrum for the third (index/offset 2) table by setting
 // frequencies above the first quarter of the spectrum to zero amplitude:
 for(i=tableLength/4; i<tableLength/2; i++)
  spectrum[i] = 0.0;

 //calculate the next postion:
 position = position + offset;

 //fill the third table (tables[2*offset]):
 fourierTransformer.getSigFromReAndIm(spectrum, tables+position);

 // copy the first sample of the table into the additional position for
 // the interpolator:
 tables[position+tableLength]   = tables[position];
 tables[position+tableLength+1] = tables[position+1];
 tables[position+tableLength+2] = tables[position+2];
 tables[position+tableLength+3] = tables[position+3];

 //and so on ... (implement it  as a loop later):

 // 4th (index/offset 3):
 for(i=tableLength/8; i<tableLength/4; i++)
  spectrum[i] = 0.0;
 position = position + offset;
 fourierTransformer.getSigFromReAndIm(spectrum, tables+position);
 tables[position+tableLength]   = tables[position];
 tables[position+tableLength+1] = tables[position+1];
 tables[position+tableLength+2] = tables[position+2];
 tables[position+tableLength+3] = tables[position+3];

 // 5th (index/offset 4):
 for(i=tableLength/16; i<tableLength/8; i++)
  spectrum[i] = 0.0;
 position = position + offset;
 fourierTransformer.getSigFromReAndIm(spectrum, tables+position);
 tables[position+tableLength]   = tables[position];
 tables[position+tableLength+1] = tables[position+1];
 tables[position+tableLength+2] = tables[position+2];
 tables[position+tableLength+3] = tables[position+3];

 // 6th (index/offset 5):
 for(i=tableLength/32; i<tableLength/16; i++)
  spectrum[i] = 0.0;
 position = position + offset;
 fourierTransformer.getSigFromReAndIm(spectrum, tables+position);
 tables[position+tableLength]   = tables[position];
 tables[position+tableLength+1] = tables[position+1];
 tables[position+tableLength+2] = tables[position+2];
 tables[position+tableLength+3] = tables[position+3];

 // 7th (index/offset 6):
 for(i=tableLength/64; i<tableLength/32; i++)
  spectrum[i] = 0.0;
 position = position + offset;
 fourierTransformer.getSigFromReAndIm(spectrum, tables+position);
 tables[position+tableLength]   = tables[position];
 tables[position+tableLength+1] = tables[position+1];
 tables[position+tableLength+2] = tables[position+2];
 tables[position+tableLength+3] = tables[position+3];

 // 8th (index/offset 7):
 for(i=tableLength/128; i<tableLength/64; i++)
  spectrum[i] = 0.0;
 position = position + offset;
 fourierTransformer.getSigFromReAndIm(spectrum, tables+position);
 tables[position+tableLength]   = tables[position];
 tables[position+tableLength+1] = tables[position+1];
 tables[position+tableLength+2] = tables[position+2];
 tables[position+tableLength+3] = tables[position+3];

 // 9th (index/offset 8):
 for(i=tableLength/256; i<tableLength/128; i++)
  spectrum[i] = 0.0;
 position = position + offset;
 fourierTransformer.getSigFromReAndIm(spectrum, tables+position);
 tables[position+tableLength]   = tables[position];
 tables[position+tableLength+1] = tables[position+1];
 tables[position+tableLength+2] = tables[position+2];
 tables[position+tableLength+3] = tables[position+3];

 // 10th (index/offset 9):
 for(i=tableLength/512; i<tableLength/256; i++)
  spectrum[i] = 0.0;
 position = position + offset;
 fourierTransformer.getSigFromReAndIm(spectrum, tables+position);
 tables[position+tableLength]   = tables[position];
 tables[position+tableLength+1] = tables[position+1];
 tables[position+tableLength+2] = tables[position+2];
 tables[position+tableLength+3] = tables[position+3];

 // 11th (index/offset 10):
 for(i=tableLength/1024; i<tableLength/512; i++)
  spectrum[i] = 0.0;
 position = position + offset;
 fourierTransformer.getSigFromReAndIm(spectrum, tables+position);
 tables[position+tableLength]   = tables[position];
 tables[position+tableLength+1] = tables[position+1];
 tables[position+tableLength+2] = tables[position+2];
 tables[position+tableLength+3] = tables[position+3];

 // 12th (index/offset 11):
 for(i=tableLength/2048; i<tableLength/1024; i++)
  spectrum[i] = 0.0;
 position = position + offset;
 fourierTransformer.getSigFromReAndIm(spectrum, tables+position);
 tables[position+tableLength]   = tables[position];
 tables[position+tableLength+1] = tables[position+1];
 tables[position+tableLength+2] = tables[position+2];
 tables[position+tableLength+3] = tables[position+3];

 */
}

//----------------------------------------------------------------------------
// fill the prototype-table with various standard waveforms:

void WaveTable::fillWithSine()
{
 for (long i=0; i<tableLength; i++)
  prototypeTable[i] = sin( (2.0*PI*i) / (double) (tableLength) );

 generateMultiSample();
}

void WaveTable::fillWithTriangle()
{
 int i;
 for (i=0; i<(tableLength/4); i++)
  prototypeTable[i] = (double)(4*i) / (double)(tableLength);

 for (i=(tableLength/4); i<(3*tableLength/4); i++)
  prototypeTable[i] = 2.0 - ((double)(4*i) / (double)(tableLength));

 for (i=(3*tableLength/4); i<(tableLength); i++)
  prototypeTable[i] = -4.0+ ((double)(4*i) / (double)(tableLength));

 generateMultiSample();
}

void WaveTable::fillWithPulse()
{
 int i;
 for (i=0; i<(tableLength/2); i++)
  prototypeTable[i] = 1.0;
 for (i=(tableLength/2); i<tableLength; i++)
  prototypeTable[i] = -1.0;

 generateMultiSample();
}

void WaveTable::fillWithSawUp()
{
 int i;
 for (i=0; i<(tableLength/2); i++)
  prototypeTable[i] = (double)(2*i) / (double)(tableLength);

 for (i=(tableLength/2); i<(tableLength); i++)
  prototypeTable[i] = (double)(2*i) / (double)(tableLength) - 2.0;

 generateMultiSample();
}

void WaveTable::fillWithSawDown()
{
 int i;
 for (i=0; i<(tableLength/2); i++)
  prototypeTable[i] = - (double)(2*i) / (double)(tableLength);

 for (i=(tableLength/2); i<(tableLength); i++)
  prototypeTable[i] = - (double)(2*i) / (double)(tableLength) + 2.0;

 generateMultiSample();
}

void WaveTable::fillWithPeakUp()
{
 int i;
 for (i=0; i<(tableLength/2); i++)
  prototypeTable[i] = 1 - (double)(2*i) / (double)(tableLength);

 for (i=(tableLength/2); i<(tableLength); i++)
  prototypeTable[i] = 0.0;

	removeDC();
	normalize();

 generateMultiSample();
}

void WaveTable::fillWithPeakDown()
{
 int i;
 for (i=0; i<(tableLength/2); i++)
  prototypeTable[i] = -1 + (double)(2*i) / (double)(tableLength);

 for (i=(tableLength/2); i<(tableLength); i++)
  prototypeTable[i] = 0.0;

	removeDC();
	normalize();

 generateMultiSample();
}

void WaveTable::fillWithMoogSaw()
{
	// the sawUp part:
 int i;
 for (i=0; i<(tableLength/2); i++)
  prototypeTable[i] = (double)(2*i) / (double)(tableLength);

 for (i=(tableLength/2); i<(tableLength); i++)
  prototypeTable[i] = (double)(2*i) / (double)(tableLength) - 2.0;

 // the triangle part:
 for (i=0; i<(tableLength/2); i++)
  prototypeTable[i] += 1 - (double)(4*i) / (double)(tableLength);

 for (i=(tableLength/2); i<tableLength; i++)
  prototypeTable[i] += -1 + (double)(4*i) / (double)(tableLength);

	removeDC();
	normalize();

 generateMultiSample();
}

void WaveTable::fillWithSqrMinusSin()
{
 fillWithPulse();

 int i;
 for (i=0; i<tableLength; i++)
  prototypeTable[i] -= sin( (2.0*PI*i) / (double) (tableLength) );

 generateMultiSample();
}

void WaveTable::fillWithTriangleModulation()
{

 int i;
 for (i=0; i<=tableLength/4; i++)
 {
  prototypeTable[i] = (double) i / (double) (tableLength/4);
  if(prototypeTable[i] > (2.0/3.0))
   prototypeTable[i] = -2.0 + 1.5*prototypeTable[i];
  else
   prototypeTable[i] = 1.5*prototypeTable[i];
 }

 for(i=1; i<=tableLength/4; i++)
 {
  prototypeTable[tableLength/4+i] = prototypeTable[tableLength/4-i];
 }
 //prototypeTable[tableLength/2-1] = 0;

 for(i=1; i<=tableLength/2-1; i++)
 {
  prototypeTable[tableLength/2+i] = -prototypeTable[tableLength/2-i];
 }
 prototypeTable[tableLength-1] = -prototypeTable[1];

 generateMultiSample();
}

void WaveTable::fillWithBrownSineOcts()
{
	// allocate buffer for the fundamental sine-wave:
	double sineBuffer[tableLength];

 int i;
 for (i=0; i<tableLength; i++)
  sineBuffer[i] = sin( (2.0*PI*i) / (double) (tableLength) );

 long   n   = 1;  
	double amp = 1;  //amplitude of the currently generated harmonic

	// calculate the highest harmonic which is to be generated (harmonics
 // should be limited to 20 kHz):
	long  maxN = (long) floor( 20000.0 / (sampleRate / tableLength) );

 initPrototypeTable();
	//fill with fundamental:
 for (i=0; i<tableLength; i++)
  prototypeTable[i] += amp * sineBuffer[i];

 //add harmonics at frequencies which are octaves above the fundamental: 
 while( pow(2.0,n) <= maxN )
 {
  amp      = 1.0/pow(2.0,n);
		long inc = (long) pow(2.0,n);
  for (i=0; i<tableLength; i++)
   prototypeTable[i] += amp * sineBuffer[ (inc*i) % tableLength];
  n++;
 }

 normalize();

 generateMultiSample();
}

void WaveTable::fillWithSawOcts()
{
	//allocate buffer for the fundamental sawtooth-wave:
	double sawBuffer[tableLength];

	//fill the buffer:
 int i;
 for (i=0; i<(tableLength/2); i++)
  sawBuffer[i] = (double)(2*i) / (double)(tableLength);
 for (i=(tableLength/2); i<(tableLength); i++)
  sawBuffer[i] = (double)(2*i) / (double)(tableLength) - 2.0;

 int    n   = 1;  
	double amp = 1;  //amplitude of the currently generated harmonic

	//calculate the highest harmonic which is to be generated (harmonics should be
	//limited to 20 kHz):
	int  maxN = (long) floor( 20000.0 / (sampleRate / tableLength) );

 initPrototypeTable();

	//fill with fundamental:
 for (i=0; i<tableLength; i++)
   prototypeTable[i] += amp * sawBuffer[i];

 //add harmonics at frequencies which are octaves above the fundamental: 
 while( pow(2.0,n) <= maxN )
 {
  amp      = 1.0/pow(2.0,n);
		int  inc = (long) pow(2.0,n);
  for (i=0; i<tableLength; i++)
   prototypeTable[i] += amp * sawBuffer[ (inc*i) % tableLength];
  n++;
 }

 normalize();

 generateMultiSample();
}

void WaveTable::fillWithNoiseCycle(int noiseColor)
{
 // init random number generator:
 srand(0);

 int i;
 for (i=0; i<tableLength; i++)
  prototypeTable[i] = ( (double) (rand()-16384) * rec16384 );

 removeDC();
 normalize();

 // filter the generated noise-cycle, if noiseColor==1 or ==2:
 if( noiseColor==1 )
 {
  // apply a White2PinkFilter to the table:
  double dummy = 0.0;
  white2pink.reset();

  // pass the table through the filter once, to overcome the transient
  // response of the filter
  for (i=0; i<tableLength; i++)
   dummy = white2pink.getSample(prototypeTable[i]);

  // the output of the second pass is written back intto the table:
  for (i=0; i<tableLength; i++)
   prototypeTable[i] = white2pink.getSample(prototypeTable[i]);
 }
 else if( noiseColor==2 )
 {
  // integrate table:
  double y_1 = 0.0;  // y[n-1] for the integrator-filter
  for (i=0; i<tableLength; i++)
  {
   prototypeTable[i] = prototypeTable[i] + y_1;
   y_1            = prototypeTable[i];
  }
 }

 removeDC();
 normalize();

 generateMultiSample();
}

void WaveTable::fillWithSineOcts(int NumOcts)
{
 //allocate buffer for the fundamental sine-wave:
 double sineBuffer[tableLength];

 int i;
 for (i=0; i<tableLength; i++)
  sineBuffer[i] = sin( (2.0*PI*i) / (double) (tableLength) );

 int   n   = 1;  

 initPrototypeTable();
 //fill with fundamental:
 for (i=0; i<tableLength; i++)
  prototypeTable[i] += sineBuffer[i];

 //add harmonics at frequencies which are octaves above the fundamental: 
 while( n < NumOcts )
 {
  double amp = 1.0/pow(2.0,n);
  long   inc = (long) pow(2.0,n);
  for (i=0; i<tableLength; i++)
   prototypeTable[i] += amp * sineBuffer[ (inc*i) % tableLength];
  n++;
 }

 normalize();

 generateMultiSample();
}

void WaveTable::fillWithSineOctsAlt(int NumOcts)
{
 //allocate buffer for the fundamental sine-wave:
 double sineBuffer[tableLength];

 int i;
 for (i=0; i<tableLength; i++)
  sineBuffer[i] = sin( (2.0*PI*i) / (double) (tableLength) );

 long   n    = 1;  
 double sign = 1;  //sign of the currently generated harmonic

 initPrototypeTable();
 //fill with fundamental:
 for (i=0; i<tableLength; i++)
  prototypeTable[i] += sign * sineBuffer[i];

 //add harmonics at frequencies which are octaves above the fundamental: 
 while( n < NumOcts )
 {
  sign       = pow(-1.0,n);
  long   inc = (long) pow(2.0,n);
  double amp = 1.0/pow(2.0,n);
  for (i=0; i<tableLength; i++)
   prototypeTable[i] += amp * sign * sineBuffer[ (inc*i) % tableLength];
  n++;
 }

 normalize();

 generateMultiSample();
}


void WaveTable::fillWithTriangleOcts(int NumOcts)
{
 //allocate buffer for the fundamental triangle-wave:
 double triangleBuffer[tableLength];

 //generate a triangle wave in the lookup-table by means of the
 //fillWithTriangle function:
 fillWithTriangle();

 //copy the triangle wave into the buffer:
 int i;
 for (i=0; i<tableLength; i++)
  triangleBuffer[i] = prototypeTable[i];

 //init exponent:
 long   n   = 1;  

 //add harmonics at frequencies which are octaves above the fundamental: 
 while( n < NumOcts )
 {
  long   inc   = (long) pow(2.0,n);
  double amp = 1.0/pow(2.0,n);
  for (i=0; i<tableLength; i++)
   prototypeTable[i] += amp * triangleBuffer[ (inc*i) % tableLength];
  n++;
 }

 normalize();

 generateMultiSample();
}

void WaveTable::fillWithTriangleOctsAlt(int NumOcts)
{
 //allocate buffer for the fundamental triangle-wave:
 double triangleBuffer[tableLength];

 //generate a triangle wave in the lookup-table by means of the
 //fillWithTriangle function:
 fillWithTriangle();

 //copy the triangle wave into the buffer:
 int i;
 for (i=0; i<tableLength; i++)
  triangleBuffer[i] = prototypeTable[i];

 //init exponent:
 long   n   = 1; 
 
 //init sign of the currently generated harmonic
 double sign = 1;  

 //add harmonics at frequencies which are octaves above the fundamental: 
 while( n < NumOcts )
 {
  sign       = pow(-1.0,n);
  long   inc = (long) pow(2.0,n);
  double amp = 1.0/pow(2.0,n);
  for (i=0; i<tableLength; i++)
   prototypeTable[i] += amp * sign * triangleBuffer[ (inc*i) % tableLength];
  n++;
 }

 normalize();

 generateMultiSample();
}

//the same for the other waveforms:
void WaveTable::fillWithPulseOcts(int NumOcts)
{
 double pulseBuffer[tableLength];
 fillWithPulse();
 int i;
 for (i=0; i<tableLength; i++)
  pulseBuffer[i] = prototypeTable[i];
 long   n   = 1;  
 while( n < NumOcts )
 {
  long   inc = (long) pow(2.0,n);
  double amp = 1.0/pow(2.0,n);
  for (i=0; i<tableLength; i++)
   prototypeTable[i] += amp * pulseBuffer[ (inc*i) % tableLength];
  n++;
 }
 normalize();
 generateMultiSample();
}
void WaveTable::fillWithPulseOctsAlt(int NumOcts)
{
 double pulseBuffer[tableLength];
 fillWithPulse();
 int i;
 for (i=0; i<tableLength; i++)
  pulseBuffer[i] = prototypeTable[i];
 long   n   = 1; 
 double sign = 1;  
 while( n < NumOcts )
 {
  sign       = pow(-1.0,n);
  long   inc = (long) pow(2.0,n);
  double amp = 1.0/pow(2.0,n);
  for (i=0; i<tableLength; i++)
   prototypeTable[i] += amp * sign * pulseBuffer[ (inc*i) % tableLength];
  n++;
 }
 normalize();
 generateMultiSample();
}
void WaveTable::fillWithSawUpOcts(int NumOcts)
{
 double sawUpBuffer[tableLength];
 fillWithSawUp();
 int i;
 for (i=0; i<tableLength; i++)
  sawUpBuffer[i] = prototypeTable[i];
 long   n   = 1;  
 while( n < NumOcts )
 {
  long   inc = (long) pow(2.0,n);
  double amp = 1.0/pow(2.0,n);
  for (i=0; i<tableLength; i++)
   prototypeTable[i] += amp * sawUpBuffer[ (inc*i) % tableLength];
  n++;
 }
 normalize();
 generateMultiSample();
}
void WaveTable::fillWithSawUpOctsAlt(int NumOcts)
{
 double sawUpBuffer[tableLength];
 fillWithSawUp();
 int i;
 for (i=0; i<tableLength; i++)
  sawUpBuffer[i] = prototypeTable[i];
 long   n   = 1; 
 double sign = 1;  
 while( n < NumOcts )
 {
  sign       = pow(-1.0,n);
  long   inc = (long) pow(2.0,n);
  double amp = 1.0/pow(2.0,n);
  for (i=0; i<tableLength; i++)
   prototypeTable[i] += amp * sign * sawUpBuffer[ (inc*i) % tableLength];
  n++;
 }
 normalize();
 generateMultiSample();
}
void WaveTable::fillWithSawDownOcts(int NumOcts)
{
 double sawDownBuffer[tableLength];
 fillWithSawDown();
 int i;
 for (i=0; i<tableLength; i++)
  sawDownBuffer[i] = prototypeTable[i];
 long   n   = 1;  
 while( n < NumOcts )
 {
  long   inc = (long) pow(2.0,n);
  double amp = 1.0/pow(2.0,n);
  for (i=0; i<tableLength; i++)
   prototypeTable[i] += amp * sawDownBuffer[ (inc*i) % tableLength];
  n++;
 }
 normalize();
 generateMultiSample();
}
void WaveTable::fillWithSawDownOctsAlt(int NumOcts)
{
 double sawDownBuffer[tableLength];
 fillWithSawDown();
 int i;
 for (i=0; i<tableLength; i++)
  sawDownBuffer[i] = prototypeTable[i];
 long   n   = 1; 
 double sign = 1;  
 while( n < NumOcts )
 {
  sign       = pow(-1.0,n);
  long   inc = (long) pow(2.0,n);
  double amp = 1.0/pow(2.0,n);
  for (i=0; i<tableLength; i++)
   prototypeTable[i] += amp * sign * sawDownBuffer[ (inc*i) % tableLength];
  n++;
 }
 normalize();
 generateMultiSample();
}



void WaveTable::fillWithSquareSweep1()
{
 static intA i, period, start, end;

 // something to do here...

 normalize();
 generateMultiSample();
}

void WaveTable::fillWithSineSweepUp(double startFreq, double endFreq)
{
 static doubleA freqRatio, log2FreqRatio, freq;
 static intA i;

 freqRatio     = endFreq/startFreq;
 log2FreqRatio = MoreMath::log2(freqRatio);

 for(i=0; i<tableLength; i++)
 {
  freq = startFreq * pow(2, (log2FreqRatio*i/tableLength) );
  prototypeTable[i] = sin(2*freq*PI*i/tableLength);  
 }

 normalize();
 generateMultiSample();
}

void WaveTable::fillWithSineSweepDown(double startFreq, double endFreq)
{
 static doubleA freqRatio, log2FreqRatio, freq;
 static intA i;

 freqRatio     = endFreq/startFreq;
 log2FreqRatio = MoreMath::log2(freqRatio);

 for(i=0; i<tableLength; i++)
 {
  freq = startFreq * pow(2, (log2FreqRatio*i/tableLength) );
  prototypeTable[i] = sin(2*freq*PI*i/tableLength);  
 }

 normalize();
 reverseTime();
 generateMultiSample();
}

void WaveTable::fillWithH1_4_7()
{
	// allocate buffer for the fundamental sine-wave:
	double sineBuffer[tableLength];

	//fill the sine buffer:
 int i;
 for (i=0; i<tableLength; i++)
  sineBuffer[i] = sin( (2.0*PI*i) / tableLengthDbl );

 long   n   = 1;  //(initial) harmonic number (is also the increment in the sine-buffer)
	double amp = 1;  //amplitude of the currently generated harmonic

	//calculate the highest harmonic which is to be generated (harmonics should be
	//limited to 20 kHz):
	long  maxN = (long) floor( 20000.0 / (sampleRate / tableLength) );

 initPrototypeTable();
 while( n <= maxN )
 {
  amp = 1.0/n;
  for (i=0; i<tableLength; i++)
   prototypeTable[i] += amp * sineBuffer[ (n*i) % tableLength];
  n += 3;
 }

 normalize();
 generateMultiSample();
}

void WaveTable::fillWithH2_5_8()
{
	//allocate buffer for the fundamental sine-wave:
	double sineBuffer[tableLength];

	//fill the sine buffer:
 int i;
 for (i=0; i<tableLength; i++)
  sineBuffer[i] = sin( (2.0*PI*i) / tableLengthDbl );

 long   n   = 2;  //(initial) harmonic number (is also the increment in the sine-buffer)
	double amp = 1;  //amplitude of the currently generated harmonic

	//calculate the highest harmonic which is to be generated (harmonics should be
	//limited to 20 kHz):
	long  maxN = (long) floor( 20000.0 / (sampleRate / tableLengthDbl) );

 initPrototypeTable();
 while( n <= maxN )
 {
  amp = 1.0/n;
  for (i=0; i<tableLength; i++)
   prototypeTable[i] += amp * sineBuffer[ (n*i) % tableLength];
  n += 3;
 }

 normalize();
 generateMultiSample();
}

void WaveTable::fillWithH3_6_9()
{
	// allocate buffer for the fundamental sine-wave:
	double sineBuffer[tableLength];

	//fill the sine buffer:
 int i;
 for (i=0; i<tableLength; i++)
  sineBuffer[i] = sin( (2.0*PI*i) / tableLengthDbl );

 long   n   = 3;   //(initial) harmonic number (is also the increment in the sine-buffer)
	double amp = 1.0; //amplitude of the currently generated harmonic

	//calculate the highest harmonic which is to be generated (harmonics should be
	//limited to 20 kHz):
	long  maxN = (long) floor( 20000.0 / (sampleRate / tableLengthDbl) );

 initPrototypeTable();
 while( n <= maxN )
 {
  amp = 1.0/n;
  for (i=0; i<tableLength; i++)
   prototypeTable[i] += amp * sineBuffer[ (n*i) % tableLength];
  n += 3;
 }

 normalize();
 generateMultiSample();
}