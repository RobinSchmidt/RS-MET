#ifndef rosic_Snowflake_h
#define rosic_Snowflake_h

namespace rosic
{

/** Snowflake is a wavetable oscillator that uses stereo waveforms generated by Lindenmayer systems. 
When left and right channel are interpreted as x,y coordinates and plotted, the resulting curves 
show a self-similar character. The Koch snowflake is one simple example of such a curve. */

class Snowflake
{

public:

  Snowflake();

  //-----------------------------------------------------------------------------------------------
  // \name Setup

  /** Sets the sample-rate. */
  void setSampleRate(double newSampleRate);

  /** Sets the frequency (in Hz) of the signal to be generated. */
  void setFrequency(double newFrequency);

  /** Sets the amplitude (as raw factor). */
  void setAmplitude(double newAmplitude) { amplitude = newAmplitude; }

  /** Sets a rotation angle (in degrees) to be applied to the produced xy coordinate pair. */
  void setRotation(double newRotation);

  //void addStereoDetune(double newDetune);

  //void addStereoFrequencyOffset(double newOffset);

  /** Sets the number of iterations for the L-system. */
  void setNumIterations(int newNumIterations);

  /** Sets the turning angle for the turtle-graphics interpreter. */
  void setAngle(double newAngle);

  /** Clears the set of L-system rules. */
  void clearRules();

  /** Adds an L-system rule. */
  void addRule(char input, const std::string& output);

  /** Sets the seed (aka "axiom") for the L-system. */
  void setAxiom(const std::string& newAxiom);

  //-----------------------------------------------------------------------------------------------
  // \name Processing

  /** Calculates one output-sample frame at a time. */
  INLINE void getSampleFrameStereo(double *outL, double *outR)
  {
    if(!tableUpToDate) updateWaveTable();
    if(!incUpToDate) updateIncrement();
    if(tableLength < 2) return;

    // integer and fractional part of position:
    int iPos = floorInt(pos);
    double fPos = pos - iPos;

    // linear interpolation, gain and rotation:
    *outL = amplitude * ((1-fPos)*tableX[iPos] + fPos*tableX[iPos+1]);
    *outR = amplitude * ((1-fPos)*tableY[iPos] + fPos*tableY[iPos+1]);
    rotator.apply(outL, outR);

    // increment and wraparound:
    pos += inc;
    while(pos >= tableLength)
      pos -= tableLength;
  }

  void reset();

  /** Renders the wavetable and updates related variables. */
  void updateWaveTable();

  /** Updates our string of turtle-graphics drawing commands. */
  void updateTurtleCommands();

protected:

  /** Updates the wavetable increment according to desired frequency, sample rate and wavetable 
  length. */
  void updateIncrement();

  // replace by LindenmayerSystem and TurtleGraphics for preparing for on-the-fly rendering
  LindenmayerRenderer renderer; 
  std::vector<double> tableX, tableY;  // rendered (wave)tables for x (left) and y (right)
  int tableLength = 0;            // not including the last sample (which repeats the 1st)
  // maybe get rid of that - switch to on-the-fly rendering (pre-render only the string), but 
  // delete only after good testing...or maybe keep it in a SnowflakePrototype class?


  LindenmayerSystem lindSys;
  TurtleGraphics turtle;

  int numIterations = 0; // replace by iteratorString or applicatorString (a string like AAABBAC)
  std::string axiom;


  // stuff for on-the fly rendering (not yet used):
  std::string lindenmayerResult;  // output string of Lindenmayer system
  std::string turtleCommands;     // only the turtle commands from lindenmayerResult 
  double meanX = 0, meanY = 0;    // mean values of x,y coordinates in one cycle
  double normalizer = 1;          // scales outputs such that -1 <= x,y <= +1 for all points
  int numPoints = 0;              // number of 'F's in turtleCommands (+1? or -1?)
  double x[2], y[2];              // x[0]: point we come from, x[1]: point we go to

  RAPT::rsRotationXY<double> rotator; // for rotating final x,y coordinates

  double pos = 0;                 // position in wavetable / string
  double inc = 0;                 // wavetable increment
  double amplitude  = 1;
  double frequency  = 0;
  double sampleRate = 1;

  std::atomic_bool commandsReady = false; // flag to indicate that "turtleCommands" is up to date
  std::atomic_bool tableUpToDate = false; // maybe rename to tableReady ...get rid
  std::atomic_bool incUpToDate = false;
  // this is a new way of dealing with updating internal variables - it avoids redundant 
  // recalculations when sereval parameters change at once and allows the re-calculation to be
  // done in a thread-safe way in the audio thread - the gui thread just atomically sets these
  // flags...maybe if we do it everywhere like this, we can even get rid of locking in 
  // jura::Parameter...that would be great!!

};

}

#endif