#ifndef rosic_Snowflake_h
#define rosic_Snowflake_h

namespace rosic
{

/** Snowflake is a wavetable oscillator that uses stereo waveforms generated by Lindenmayer systems. 
When left and right channel are interpreted as x,y coordinates and plotted, the resulting curves 
show a self-similar character. The Koch snowflake is one simple example of such a curve. 

not yet finished
*/

class Snowflake
{

public:

  Snowflake();

  //-----------------------------------------------------------------------------------------------
  // \name Setup

  /** Sets the sample-rate. */
  void setSampleRate(double newSampleRate);

  /** Sets the frequency (in Hz) of the sine to be generated. */
  void setFrequency(double newFrequency);

  /** Sets the number of iterations for the L-system. */
  void setNumIterations(int newNumIterations);

  /** Sets the turning angle for the turtle-graphics interpreter. */
  void setAngle(double newAngle) { renderer.setAngle(newAngle); }

  /** Clears the set of L-system rules. */
  void clearRules() { renderer.clearRules(); }

  /** Adds an L-system rule. */
  void addRule(char input, const std::string& output) { renderer.addRule(input, output); }

  /** Sets the seed (aka "axiom") for the L-system. */
  void setSeed(const std::string& newSeed) { seed = newSeed; }
    // rename to setAxiom

  //-----------------------------------------------------------------------------------------------
  // \name Processing

  /** Calculates one output-sample frame at a time. */
  INLINE void getSampleFrameStereo(double *outL, double *outR)
  {
    if(tableLength < 2) return;

    // integer and fractional part of position:
    int iPos = floorInt(pos);
    double fPos = pos - iPos;

    // linear interpolation:
    *outL = (1-fPos)*x[iPos] + fPos*x[iPos+1];
    *outR = (1-fPos)*y[iPos] + fPos*y[iPos+1];

    // increment and wraparound:
    pos += inc;
    while(pos >= tableLength)
      pos -= tableLength;
  }

  void reset();

  /** Renders the wavetable and updates related variables. */
  void updateWaveTable();

protected:

  /** Updates the wavetable increment according to desired frequency, sample rate and wavetable 
  length. */
  void updateIncrement();

  std::vector<double> x, y;       // rendered (wave)tables for x (left) and y (right)
  LindenmayerRenderer renderer;
  int numIterations = 0;
  std::string seed;
  double pos = 0;                 // position in wavetable
  double inc = 0;                 // wavetable increment
  double frequency  = 0;
  double sampleRate = 1;
  int tableLength = 0;            // not including the last sample (which repeats the 1st)

};

}

#endif