#ifndef rosic_Oscillator_h
#define rosic_Oscillator_h

//// rosic-indcludes:
//#include "rosic_MipMappedWaveTableOld.h"

namespace rosic
{

  /**

  This is a table-lookup oscillator with linear interpolation. There are several standard waveforms 
  as well as white noise and pink noise (therefore a White2PinkFilter object is embedded) and a lot 
  of special waveforms. The output samples can be generated by the simple getSample()-function or 
  by the more elaborate getSampleAntiAliased()-function.

  */

  class Oscillator
  {

  public:

    //---------------------------------------------------------------------------------------------
    // construction/destruction:

    /** Constructor. */
    Oscillator();

    /** Destructor. */
    ~Oscillator();

    //---------------------------------------------------------------------------------------------
    // parameter settings:

    /** Sets the sample-rateRate(). */
    void setSampleRate(double newSampleRate);

    /** Sets the waveform of the oscillator. */
    void setWaveForm(int newWaveForm);

    /** Set start phase (range 0 - 360 degrees). */
    void setStartPhase(double StartPhase);
   
    /** An object of class WaveTable should be passed with this function which will be used in the 
    oscillator. Not to have "our own" WaveTable-object as member-variable avoids the need to have 
    the same waveform for different synth-voices multiple times in the memory. */
    void setWaveTable(MipMappedWaveTableOld* newWaveTable);
 
    /** Sets the frequency of the oscillator. */
    INLINE void setFrequency(double newFrequency);

    /** Sets the pulse width (or symmetry) of the oscillator. */
    INLINE void setPulseWidth(double newPulseWidth);

    //---------------------------------------------------------------------------------------------
    // inquiry:

    /** Returns the current phase-increment per sample. */
    double getIncrement();

    //---------------------------------------------------------------------------------------------
    // audio processing:

    /** Calculates a single output-sample by means of linear interpolation. This is the 
    LoFi-version because no anti-aliasing algorithm is used. For better quality use the 
    getSampleAntiAliased() method - but this, of course, requires more CPU. */
    INLINE double getSampleDraft();

    /** Calculates an anti-aliased output sample. The anti aliasing is achieved via a multi-sampled 
    table, where each of the successive tables halves the spectral content. To choose, which table 
    is to be used, the exponent of the phase-increment is extracted. */
    INLINE double getSample();


    INLINE double getSampleOld();   // ??

    //---------------------------------------------------------------------------------------------
    // others:

    /** Calculates the phase-increments for first and second half-period according to freq and 
    pulseWidth. */
    INLINE void calculateIncrements();

    /** Resets the phaseIndex to startIndex. */
    void resetPhase();

    /** Reset the phaseIndex to startIndex+PhaseIndex. */
    void setPhase(double PhaseIndex);

    /** Reset the phaseIndex to startIndex+initialPhaseAdvance and resets the blepPostion to 
    ... */
    void triggerSync(double timeStamp);

    //---------------------------------------------------------------------------------------------
    // info for an outlying class:

    //bool wraparoundOccurred;
    /**< This flag is true only once per cycle - it is set, everytime the
    phaseIndex is wrapped around. It can be accessed from outside and is
    meant to be used for syncing other oscillators. */

    //=============================================================================================

  protected:

    // frequently used data into the 1st 128 bytes:
    doubleA tableLengthDbl,             // tableLength as double variable
      tableLengthDiv2Dbl,
      tableLengthMinus1Dbl,
      tableLengthRec;             // 1/tableLength

    doubleA phaseIndex;                 // current phase index


    doubleA previousOutput; // remembers the previous output-sample which will be
    // needed to determine the size of the minBlep which is to be added to the
    // signal.

    doubleA freq;                       // frequency of the oscillator
    doubleA pulseWidth;                 // the pulse-width
    doubleA basicIncrement;             // increment for both half-waves when
    // PW is 50%
    doubleA increment1, increment2;     // phase increment for 1st and 2nd
    // half-wave

    doubleA pulseFactor1, pulseFactor2; // factor to calculate increment1 and
    // increment2 from basicIncrement (are
    // dependent on pulseWidth)

    intA    waveForm;                   // index of the waveform
    doubleA startIndex;                 // start-phase-index of the osc
    // (range: 0 - tableLength)

    doubleA sampleRate;
    doubleA sampleRateRec;              // reciprocal of the sampleRate
    doubleA rec16384;                   // reciprocal of 16384


    static doubleA blep[8193];          // array with a mininmum-phase bandlimited-step ('minBlep')

    static const intA blepLength = 8193; // length of the minBlep-array


    doubleA blepLengthDbl; // same value but in double-format

    doubleA blepOversampling;
    // oversampling factor of the blep - is assigned once for all to 128.0 in
    // the constructor

    doubleA blepIncrement;
    doubleA blepPosition;   // current readout-position in the blep.
    doubleA blepSizeScaler; //
    doubleA blepStartLevel; // in test

    // embedded objects:
    WhiteToPinkFilter      white2pink;
    MipMappedWaveTableOld* waveTable; // a pointer to a wavetable-object

  };

  //-----------------------------------------------------------------------------------------------
  // from here: definitions of the functions to be inlined, i.e. all functions which are supposed 
  // to be called at audio-rate (they can't be put into the .cpp file):

  INLINE void Oscillator::setFrequency(double newFrequency)
  {
    if( (newFrequency > 0.0) && (newFrequency < 20000.0) )
      freq = newFrequency;
  }

  INLINE void Oscillator::setPulseWidth(double newPulseWidth)
  {
    if( (newPulseWidth>0.01) && (newPulseWidth<0.99) )
      pulseWidth = newPulseWidth;
  }

  INLINE void Oscillator::calculateIncrements()
  {
    //calculate the increment as if there were no pulseWidth-parameter:
    basicIncrement = tableLengthDbl*freq*sampleRateRec;

    //calculate factors for the increments for 1st and 2nd half-wave
    pulseFactor1   = 1.0/(pulseWidth*2.0);
    pulseFactor2   = 1.0/((1-pulseWidth)*2.0);

    //the increment for the 1st and 2nd half-wave are derived via the pulse-factor:
    increment1     = basicIncrement*pulseFactor1;
    increment2     = basicIncrement*pulseFactor2;
  }

  INLINE double Oscillator::getIncrement()
  {
    return basicIncrement;
  }

  INLINE double Oscillator::getSampleDraft()
  {
    //static double increment, tmpNoise;

    return 0.0;
  }


  INLINE double Oscillator::getSample()
  {
    //doubleA floorOfIndex;               // integer part of phaseIndex as
    // double variable
    //doubleA fracIndex;                  // fractional part of phaseIndex

    doubleA increment, tmpNoise, out = 0;
    doubleA blepPositionFloor, blepPositionFrac, blepValue;
    //intA    intIndex;                   // integer part of phaseIndex
    intA    blepPositionInt;
    intA    tableNumber;

    if( waveTable == NULL )
      return 0.0;

    if(waveForm>=3)  // oscillator is really playing a waveform from the
      // lookup-table for lower values of waveForm it outputs
      // either noise (1,2) or nothing (0)
    {
      // check if we are in first or second half-wave and choose the appropriate
      // increment:
      if( phaseIndex < tableLengthDiv2Dbl ) //first half-period
        increment = increment1;
      else
        increment = increment2;

      // from this increment, decide which table is to be used:
      tableNumber  = ((int)EXPOFDBL(increment));
      tableNumber += 1; // generates frequencies up to nyquist/2 on the highest
      // note
      if( tableNumber<=0 )
        tableNumber = 0;
      else if ( tableNumber>11 )
        tableNumber = 11;

      // wraparound if necessary:
      while ( phaseIndex>=tableLengthDbl )
      {
        phaseIndex = phaseIndex - tableLengthDbl;
      }

      /*
      // forward-warparound for cases when phaseIndex is negative (can occur due
      // to sync):
      while ( phaseIndex<0.0 )
      {
      phaseIndex = phaseIndex + tableLengthMinus1Dbl;
      }
      */

      // O.K. phaseIndex is assured to be valid now - read out the table:
      //out = waveTable->getValueLinear(phaseIndex, tableNumber);
      out = waveTable->getValueHermite(phaseIndex, tableNumber);

      // add a properly scaled minBlep:
      if( blepPosition >= blepLengthDbl-2.0  || blepPosition < 0.0 )
        blepValue = 1.0;
      else
      {
        // calculate integer and fractional part of the blepPosition:
        blepPositionFloor = floor(blepPosition);       // integer part as double
        blepPositionFrac  = blepPosition - blepPositionFloor;// fractional part
        blepPositionInt   = (int) blepPositionFloor;         // integer part as int

        // lookup the blep-value in the blep-array with linear interpolation:
        blepValue = blep[blepPositionInt]
        + blepPositionFrac*(blep[blepPositionInt+1]-blep[blepPositionInt]);

        blepPosition += blepIncrement;
      }
      //out -= (1.0-blepValue) * blepSizeScaler; // add the blep
      out = blepValue*out + (1.0-blepValue)*blepStartLevel; // test (bandlimited switch)

      // remember output-sample for determination of the blep-Size in the
      // triggerSync()-function:
      previousOutput = out;

      // calculate new phase-index for the next iteration:
      phaseIndex = phaseIndex + increment;
    }

    else if(waveForm==1) //white noise
      out = ( (double) (rand()-16384) * rec16384 ); //rand() produces integer numbers between
    //0 and 32768
    else if(waveForm==2) //pink noise
    {
      tmpNoise = ( (double) (rand()-16384) * rec16384 ); //white noise bewtween -1 and 1
      tmpNoise = white2pink.getSample(tmpNoise);
      out = tmpNoise;
    }

    return out;
  }

  INLINE double Oscillator::getSampleOld()
  {
    static doubleA increment, tmpNoise, out;
    static doubleA blepPositionFloor, blepPositionFrac, blepValue;
    static intA    blepPositionInt;
    static intA    tableNumber;

    if( waveTable == NULL )
      return 0.0;

    if(waveForm>=3)  // oscillator is really playing a waveform from the
      // lookup-table for lower values of waveForm it outputs
      // either noise (1,2) or nothing (0)
    {
      // check if we are in first or second half-wave and choose the appropriate
      // increment:
      if( phaseIndex < tableLengthDiv2Dbl ) //first half-period
        increment = increment1;
      else
        increment = increment2;

      // from this increment, decide which table is to be used:
      tableNumber  = ((int)EXPOFDBL(increment));
      tableNumber += 1; // generates frequencies up to nyquist/2 on the highest
      // note
      if( tableNumber<=0 )
        tableNumber = 0;
      else if ( tableNumber>11 )
        tableNumber = 11;

      // wraparound if necessary:
      while ( phaseIndex>=tableLengthDbl )
      {
        phaseIndex = phaseIndex - tableLengthDbl;
        //wraparoundOccurred = true; //set flag - only needed for osc1 in aggressor
      }

      // forward-warparound for cases when phaseIndex is negative (can occur due
      // to sync):
      while ( phaseIndex<0.0 )
      {
        phaseIndex = phaseIndex + tableLengthMinus1Dbl;
      }

      // O.K. phaseIndex is assured to be valid now - read out the table:
      out = waveTable->getValueLinear(phaseIndex, tableNumber);

      // add a properly scaled minBlep:
      if( blepPosition >= blepLengthDbl-2.0  || blepPosition < 0.0 )
        blepValue = 1.0;
      else
      {
        // calculate integer and fractional part of the blepPosition:
        blepPositionFloor = floor(blepPosition);       // integer part as double
        blepPositionFrac  = blepPosition - blepPositionFloor;// fractional part
        blepPositionInt   = (int) blepPositionFloor;         // integer part as int

        // lookup the blep-value in the blep-array with linear interpolation:
        blepValue = blep[blepPositionInt]
        + blepPositionFrac*(blep[blepPositionInt+1]-blep[blepPositionInt]);

        blepPosition += blepIncrement;
      }
      //out -= (1.0-blepValue) * blepSizeScaler; // add the blep
      out = blepValue*out + (1.0-blepValue)*blepStartLevel; // test (bandlimited switch)

      // remember output-sample for determination of the blep-Size in the
      // triggerSync()-function:
      previousOutput = out;

      // calculate new phase-index for the next iteration:
      phaseIndex = phaseIndex + increment;
    }

    else if(waveForm==1) //white noise
      out = ( (double) (rand()-16384) * rec16384 ); //rand() produces integer numbers between
    //0 and 32768
    else if(waveForm==2) //pink noise
    {
      tmpNoise = ( (double) (rand()-16384) * rec16384 ); //white noise bewtween -1 and 1
      tmpNoise = white2pink.getSample(tmpNoise);
      out = tmpNoise;
    }

    return out;
  }

} // end namespace rosic

#endif // rosic_Oscillator_h
