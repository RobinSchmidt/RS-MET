----------------------------------------------------------------------------------------------------
SFZ parsing and generation
==========================

- Define and implement parsing for modulation routing opcodes. (Done?)

- Define some aliases for certain routings. For example fileg_depth should be an alias for routing
  the (first) filter envelope (i.e. the first EnvGenFil in the modSources array) to the first filter
  in the effectChain.
  
- Currently, we use std::stof for converting strings to floating point numbers (wrapped into 
  rsStringToFloat). This may lead to errors in a float -> string -> float roundtrip. We should use
  a better implementation that allows for exact roundtrips. Maybe drag the old rsBigFloat code from
  RSLib into RAPT or rosic. This contains - among many other things - also a proper string -> float
  parsing implementation. ...but maybe it's the float -> string part that's at fault? Or maybe even 
  both? -> Check that!

- What if fileg_attack etc. opcodes exist but no cutoff opcode? Should we insert a filter with
  a default cutoff and route the fileg to that? Or should the fileg opcodes be ignored? Similarly 
  what if ampeg_attack opcodes exist but no amplitudeN opcode? Should we implicitly insert an 
  amplifier? Maybe yes. The difference to the cutoff opcode is, that an amplitudeN opcode actually 
  does not even exist in the SFZ1 spec (only in the ARIA spec).
  
- Replace all calls to to_string with rsFloatToString in order to later replace the implementation.
  Currently it just delegates to std::to_string but we may need soemthing better.
  
- Support the following opcodes:
  https://sfzformat.com/opcodes/default_path

----------------------------------------------------------------------------------------------------
Sample playback
===============

- Redesign the way, the sample playback works: Make the SamplePlayer a subclass of Processor just 
  like all the other signal processors. This may have some side benefits of simplfiying the code for
  the opcode accumulation vs override behavior (no special casing for SamplePlayer opcodes anymore)
  and we will automatically also be able to modulate the loop start and end points. With suitable 
  samples, this will allow a wavtable synthesis a la Waldorf and also perhaps some sort of dubstep 
  growls (apply loop-modulation to noisy or percussive samples).
  
- Maybe switch to an int+float representation of the current sample position and increment and 
  check, if this improves performance...even if not, it's still better because it doesn't lose 
  precision for later samples
  
- Implement and test better realtime resampling (linear interpolation at first, later cubic and
  sinc, maybe some sort of "Elephant" interpolation, too - although, they are supposed to work 
  with 2x oversampling). But maybe a bit of oversampling would be beneficial anyway.
  - we need a double for the sample-time and an increment...but later, that increment shall be
    modulated by pitch-env and -lfo, or maybe use and int and a a float to represent sampleTime
    and increment -> do benchmarks, which is faster
  - Should the played note affect the delay?...nah - i don't think so. maybe sfz had an opcode 
    for controlling this? in some situations, that may makes sense (for creating comb-filter 
    effects), in others not so much

- Maybe we could also use mip-maps or integrated (lowpass-filtered) samples in memory and apply 
  the inverse filter during playback (after resampling).
  
- Support the following opcodes:  
  https://sfzformat.com/opcodes/direction
  https://sfzformat.com/opcodes/loop_crossfade
  https://sfzformat.com/opcodes/loop_type
  https://sfzformat.com/opcodes/loop_count

----------------------------------------------------------------------------------------------------
Effect chain
============

- Implement support of arbitrary (single cycle) waveforms for the LFOs. Maybe they don't even need 
  to be single-cycle. We could also support arbitrary samples with loops. By default, we would use
  a loop_start of 0 and loop_end of N. Having this in place will also make it easier to implement
  the same thing for the sample player which is a necessary step for supporting pitch envelopes.

- Implement different filter topologies which are automatically selected according to the sfz data

- Provide an automatic gain compensation for the whole effect chain by measuring the loudness of 
  the input i.e. the source signal at the start of the effect chain and at the end of the effect 
  chain, compute the gain difference and apply an inverse gain. The loudness measurement can either
  be done in realtime to apply a dynamic gain comepnsation or by doing some sort of precomputation 
  and the applying a static gain. If it's done in realtime, we may want some sort of envelope 
  follower with look-ahead. To compensate the latency introduced by that, we may need a 
  render-ahead functionality. Maybe when the user plays a note, we should render a few hundreds of
  samples ahead of the time when they are actually needed? ...that may be messy to implement, 
  though.

- Support the following opcodes:  
  https://sfzformat.com/opcodes/bus
  https://sfzformat.com/opcodes/pan_keycenter
  https://sfzformat.com/opcodes/pan_keytrack
  https://sfzformat.com/opcodes/pan_veltrack

----------------------------------------------------------------------------------------------------
Modulation system
=================

- Figure out, if the fileg_depth should apply to all filter cutoffs simultaneously by checking 
  whether or not it affects both filters in sfz2. If so, make it so.
  
- Automatically route the ampeg_attack etc. parameters to the last Amplifier unit in the chain. If
  ther is none, insert one at the end. Or: maybe always insert an Amplifier at the end, if the last 
  module is not an amp?

- Figure out what the correct behavior with regard to start/delay is - should we output zero or
  start during the delay phase? We need to test this using a reference implementation like 
  sfz+. The zip-archive dwonloadable from here: https://plugins4free.com/plugin/217/ contains 
  sfz197.exe and SFZ.pdf whcih discusses the envelopes on page 12 (pagenumber is 82). It doesn't
  mention a start parameter at all.
   
- Verify the formula for vel_tracking of amplitude against some reference implementation (sfz+)   

- Maybe we should not define ADSR parameters for egN because in SFZ2, the egN opcodes work in 
  terms of egN_timeX egN_levelX. Maybe use adsrN instead. Or maybe the ADSR parameters can be
  interpreted as aliases like delay = time0, start = level0, attack = time1, peak = level1,
  hold = time2, peak = level2 (yes, again - peak maps to level 1 and 2), decay = time3,
  sustain = level3, release = time4, end = level4? Figure out, if that makes sense. But: it 
  would imply that we would need MSEGs even for ADSRs and MSEGs are probably more complex to
  implement, so maybe it's indeed better to use adsrN here.
  DONE: Renamed egN_attack etc. to adsrN_attack etc.
  
- Maybe we could allow a syntax egN_cutoffAll or egN_cutoffA and/or egN_cutoffLast or egN_cutoffL to
  use a single command to conveniently specify a whole bunch of modulation routings.
   
- Release-Modes: 
  - one_shot: always run through the whole envelope even when noteOff is triggered before 
    reaching sustain (this is the current behavior)
  - immediate: enter release phase immediately, starting from current level   
   
- Retrigger-Modes: determine behavior when a new noteOn is received during the release of a
  voice/layer playing the same note
  - new_layer: a new layer is started while the old one just keeps releasing (this is the 
    current behavior, I think)
  - restart: re-uses the releasing voice/layer and retriggers the envelope from the beginning,
    LFOs (if any) should keep running
  - restart_from_current: like restart but does not restart the envelope from its start level 
    but from where it currently is.
  - pile_up: like restart_from_current, but in a rapid succession of notes, the envelopes pile
    up on each other like the filter-based ones triggered by impulses would do (see Experiments 
    with class rsAttackDecayEnvelope for how this behaves)
  - Let the user select the shapes for the different stages

- Maybe we should handle the fixed/hardwired modulations, i.e. filegN, ampegN, pitchegN, 
  opcodes as follows:
  - Implement a function translateHardwiredOpcodes that is supposed to be called at the end of
    setFromSfz and should do the following:
    - Figure out maxN, the maximum N in the existing egN opcodes.
    - Translate the filegN, ampegN, pitchegN to egN opcodes with N values above maxN.
    - Translate filegN_depth, pitchegN_depth to appropriate modulation routing opcodes.
  - Advantages:
    - We can handle all envelopes in a unified way. In particular, we don't need separate arrays
      for ampEnvs, pitchEnvs, filterEnvs in the DspPool.
  - Disadvantages:
    - When writing the state to an sfz file, we lose the information about what egN opcodes 
      formerly actually were hardwirded opcodes. Unless we somehow store that information in the
      egN opdcodes.
	  
- Optimize the envelope code and use the current code as prototype to compare against in a unit
  test. At the moment, we only plot stuff here and do not yet do any actualy unit tests
  
- Figure out what happens when the noteOff is received before the sustain phase is entered and
  check if the behavior matches what is desired. We probably need to implement the EG 
  recursively using somthing like y += dy	

- Implement different shapes for the segments. See:
    https://sfzformat.com/opcodes/ampeg_attack_shape
    https://sfzformat.com/opcodes/ampeg_release_shape
    https://sfzformat.com/opcodes/ampeg_decay_shape
  analogous opcodes exist for fileg and pitcheg. These are opcodes specified in ARIA. For the 
  egN opcodes, there is the 
    https://sfzformat.com/opcodes/egN_shapeX
  opcode defined in SFZ2. The egN opcodes are apparently supposed to be MSEGs rather than 
  extended ADSR envelopes. They are defined via 
    https://sfzformat.com/opcodes/egN_levelX
    https://sfzformat.com/opcodes/egN_timeX
  opcodes. Maybe we should define, for example, ampeg_attack as alias for ampeg_time1 which in 
  turn is internally translated to egM_time1 where M is chosen to be > max(N) for the 
  user-defined egN opcodes. And/or egN_attack is just an alias for egN_time1

- Implement pitch EGs after the redesign of the SamplePlayer explained above. Pitch EGs are then 
  just regular EGs routed to transpose and/or tune opcodes which are opcodes of the SamplePlayer
  Processor. Maybe pitcheg_depth should be interpreted as an alias for routing the pitcheg to the
  tune parameter of the first sample player because both opcodes operate with cents:
    https://sfzformat.com/opcodes/pitcheg_depth
    https://sfzformat.com/opcodes/tune
  whereas transpose expect an integer (I guess in units of semitones):
	https://sfzformat.com/opcodes/transpose

- Implement MSEGs. Maybe when they are in place, the extended ADSRs can be implemented in terms of 
  them as special case. Maybe as subclass, maybe using some aliases for the opcodes - we'll see.
  
- Implement optional dynamic recalculation of envelope durations in response to MIDI CCs, see:  
    https://sfzformat.com/opcodes/ampeg_dynamic
	
- Support the following opcodes: 	
  https://sfzformat.com/opcodes/lfoN_phase
  https://sfzformat.com/opcodes/lfoN_count	
  
----------------------------------------------------------------------------------------------------
MIDI behaviors
============== 
  
- Support the following opcodes:   
  https://sfzformat.com/opcodes/polyphony
  https://sfzformat.com/opcodes/note_selfmask  
  https://sfzformat.com/opcodes/set_ccN
  https://sfzformat.com/opcodes/rt_dead

- See this video for inspiration for how to implement different glide/legato/retrigger modes in
  monophonic operation:
  https://www.youtube.com/watch?v=7hjhkPhxQLc&list=PLlczpwSXEOybYYaBCTcjxxKz1QmxytbIf&index=12
  Whether or not a note is being held while a new noteOn arrives can be used to switch between
  - Invoking a glide or immediately jumping to the new frequency. Maybe glide should have the 
    modes: (1) "never", (2) "legato": glide only when note is held, (3) "always"
  - Retriggering or not retriggering the envelope(s). Maybe this should be a feature of each 
    envelope seperately. We may retrigger some envelopes but not others. It could have the modes:
    (1) "always", (2) "portato": retrigger only when note is not held. Other modes like "never" or
    "legato" do not seem to be useful
  - Implement constant rate/speed vs constant time glide. The former has a constant rate like 
    1 octave´per second whereas the latter always needs the same amount of time to reach the new 
    note, no matter hwo far away it is from the old. Maybe the "exponential" mode in the video is
    using an RC lowpass?
  - What about the glide curves? Should we use the same curves as for the envelopes? Maybe a linear
    glide in the pitch domain is the most musically natural? Or maybe using RC-filtering is better?
    I think, RC-filters are the same as a linear-pitch-glide for glide-down but inverted/mirrored 
    curves for glide-up.
  - It has this interesting "gated" glide mode. While that may indeed be not that useful, what 
    about immediately jumping to the new note at the moment, the old one is released? This would 
    also "stop gliding" - but not just stop wherever it happens to be at that moment but jump to
    target. ...maybe it could be called "jump_on_release" or something
  - Maybe glide should be available per sample/source. At the moment, we only have one sample per
    region anyway, but we want more in the future

----------------------------------------------------------------------------------------------------
Effects
=======

- Autogain: Analyzes the gain difference between the signal at the input of the effect chain and 
  its own input and applies an inverse gain to compensate (partially or fully) for the measured
  difference. The goal is to make the signal come out of the effect chain with the same loudness as
  it enters the effect chain. We would either somehow need to sidechain the original input into a
  sidechain input or just somehow have a hardwired levelmeter at the input of the chain, whenever
  an Autogain effect is present. Sidechain inputs could be useful anyway...but how would we define
  the routing in the the sfz? The parameters of such an autogain device could be: attack, release,
  amount. Maybe also mode (RMS, Peak, loudness, etc.). Maybe it could also use lookahead. That would
  require to pre-render some samples/blocks before they are actually needed.



===================================================================================================
Fine-grained llist of basic tasks to do next (in order)

-Presets showcasing all currently implemented features:
 -Modulation of 3 EQ-frequencies (in notch-peak-notch configuration at 500/1000/2000) to simualte 
  smallstone-phaser as Niko explained. Do that on the region-level and on the group (or global level)

-Figure out (and fix, if necessary) the desired behavior of the Amp-LFO depth: sould it go up and 
 down by X decibels or is X the peak-to-peak modulation depth? Compare to reference sfz player.
-Implement responses to MIDI controllers, make them available as modulators
-Finish features of LFO, EG (release behavior)
-Throw total nonsense at the sfz parser and make sure, it handles it gracefully. There are 
 some commented lines in samplerParserTest which already do a bit of this. Uncomment these, 
 make them pass and add more of such tests.
-Make a sfzCodeBookTest that tests the from/to string conversions
-Maybe implement the patches in a cpp-file like
 RS-MET\Tests\TestsRosicAndRapt\Source\rosic_tests\rosic_GeneratorsTests.cpp
 and produce reference output and turn them into unit tests...but the reference output should go
 into the RS-MET-Tests repo. Actually, it may be better to produce .sfz files and let the unti 
 tests load them - that would also test the loading mechanism


