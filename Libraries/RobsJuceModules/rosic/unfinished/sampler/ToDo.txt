

----------------------------------------------------------------------------------------------------
Effect chain
============

- Redesign the way, the sample playback works: Make the SamplePlayer a subclass of Processor just 
  like all the other signal processors. This may have some side benefits of simplfiying the code for
  the opcode accumulation vs override behavior (no special casing for SamplePlayer opcodes anymore)
  and we will automatically also be able to modulate the loop start and end points. With suitable 
  samples, this will allow a wavtable synthesis a la Waldorf and also perhaps some sort of dubstep 
  growls (apply loop-modulation to noisy or percussive samples).

----------------------------------------------------------------------------------------------------
Modulation system
=================

- Define and implement parsing for modulation routing opcodes.

- Define some aliases for certain routings. For example fileg_depth should be an alias for routing
  the (first) filter envelope (i.e. the first EnvGenFil in the modSources array) to the first filter
  in the effectChain.

- Figure out what the correct behavior with regard to start/delay is - should we output zero or
   start during the delay phase? We need to test this using a reference implementation like 
   sfz+.

- Maybe we should handle the fixed/hardwired modulations, i.e. filegN, ampegN, pitchegN, 
  opcodes as follows:
  - Implement a function translateHardwiredOpcodes that is supposed to be called at the end of
    setFromSfz and should do the following:
    - Figure out maxN, the maximum N in the existing egN opcodes.
    - Translate the filegN, ampegN, pitchegN to egN opcodes with N values above maxN.
    - Translate filegN_depth, pitchegN_depth to appropriate modulation routing opcodes.
  - Advantages:
    - We can handle all envelopes in a unified way. In particular, we don't need separate arrays
      for ampEnvs, pitchEnvs, filterEnvs in the DspPool.
  - Disadvantages:
    - When writing the state to an sfz file, we lose the information about what egN opcodes 
      formerly actually were hardwirded opcodes. Unless we somehow store that information in the
      egN opdcodes.
	  
- Optimize the envelope code and use the current code as prototype to compare against in a unit
  test. At the moment, we only plot stuff here and do not yet do any actualy unit tests
  
- Figure out what happens when the noteOff is received before the sustain phase is entered and
  check if the behavior matchesn what is desired. We probably need to implement the EG 
  recursively using somthing like y += dy	

- Implement different shapes for the segments. See:
    https://sfzformat.com/opcodes/ampeg_attack_shape
    https://sfzformat.com/opcodes/ampeg_release_shape
    https://sfzformat.com/opcodes/ampeg_decay_shape
  analogous opcodes exist for fileg and pitcheg. These are opcodes specified in ARIA. For the 
  egN opcodes, there is the 
    https://sfzformat.com/opcodes/egN_shapeX
  opcode defined in SFZ2. The egN opcodes are apparently supposed to be MSEGs rather than 
  extended ADSR envelopes. They are defined via 
    https://sfzformat.com/opcodes/egN_levelX
    https://sfzformat.com/opcodes/egN_timeX
  opcodes. Maybe we should define, for example, ampeg_attack as alias for ampeg_time1 which in 
  turn is internally translated to egM_time1 where M is chosen to be > max(N) for the 
  user-defined egN opcodes. And/or egN_attack is just an alias for egN_time1
  